# -*- coding: utf-8 -*-
"""modified_ui.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ISMu32r4gKKhDkk1jI3kQOPJ_XCRoV5K

# Visualize Function
"""

# @title
import pandas as pd
import numpy as np
import random
import math
import plotly.graph_objects as go
import plotly.express as px
from plotly.subplots import make_subplots

colors = px.colors.qualitative.G10
colors_dict = {
    'blue': 'royalblue',
    'red': 'tomato',
    'orange': colors[2],
    'green': colors[3],
    'purple': colors[4],
    'cyan': colors[5],
    'magenta': colors[6],
    'sage': colors[7],
    'maroon': colors[8],
    'navy': colors[9],
    'gray': 'gray',
    'lightgray': 'lightgray',
    'black': 'rgba(62, 62, 62,1)'
}

legends = ["legend"]
for i in range(2, 17):
    legends.append("legend"+str(i))

axes = ['xaxis', 'yaxis']
for i in range(16):
    axes.append('xaxis'+str(i+1))
    axes.append('yaxis'+str(i+1))

# inisiasi kolom data
depth = "DEPTH"


data_col = {
    'DNS': ['DNS'],
    'MARKER': ['MARKER'],
    'GR': ['GR'],
    'GR_NORM': ['GR_NORM'],
    'GR_DUAL': ['GR', 'GR_NORM'],
    'GR_DUAL_2': ['GR_RAW', 'GR_NORM'],
    'GR_RAW_NORM': ['GR_RAW_NORM'],
    'GR_MovingAvg_5': ['GR_MovingAvg_5'],
    'GR_MovingAvg_10': ['GR_MovingAvg_10'],
    'RT': ['RT'],
    'RT_RO': ['RT', 'RO'],
    'X_RT_RO': ['RT_RO'],
    'NPHI_RHOB_NON_NORM': ['NPHI', 'RHOB'],
    'RHOB': ['RHOB'],
    'NPHI_RHOB': ['NPHI', 'RHOB', 'NPHI_NORM', 'RHOB_NORM_NPHI'],
    'SW': ['SW'],
    'PHIE_PHIT': ['PHIE', 'PHIT'],
    'PERM': ['PERM'],
    'VCL': ['VCL'],
    'RWAPP_RW': ['RWAPP', 'RW'],
    'X_RWA_RW': ['RWA_RW'],
    'RT_F': ['RT', 'F'],
    'X_RT_F': ['RT_F'],
    'RT_RHOB': ['RT', 'RHOB', 'RT_NORM', 'RHOB_NORM_RT'],
    'X_RT_RHOB': ['RT_RHOB'],
    'TEST': ['TEST'],
    'XPT': ['XPT'],
    'RT_RGSA': ['RT', 'RGSA'],
    'NPHI_NGSA': ['NPHI', 'NGSA'],
    'RHOB_DGSA': ['RHOB', 'DGSA'],
    'ZONA': ['ZONA'],
    'VSH': ['VSH'],
    'SP': ['SP'],
    'VSH_LINEAR': ['VSH_LINEAR'],
    'VSH_DN': ['VSH_DN'],
    'VSH_SP': ['VSH_SP'],
    'PHIE_DEN': ['PHIE', 'PHIE_DEN'],
    'PHIT_DEN': ['PHIT', 'PHIT_DEN'],
    'RESERVOIR_CLASS': ['RESERVOIR_CLASS'],
    'RWA': ['RWA_FULL', 'RWA_SIMPLE', 'RWA_TAR'],
    'PHIE': ['PHIE'],
    'RT_GR': ['RT', 'GR', 'RT_NORM', 'GR_NORM_RT'],
    # 'RT_PHIE':['RT','PHIE','RT_NORM', 'PHIE_NORM_RT'],
    'RT_PHIE': ['RT', 'PHIE'],
    'RGBE': ['RGBE'],
    'RPBE': ['RPBE'],
    'RGBE_TEXT': ['RGBE'],
    'RPBE_TEXT': ['RPBE'],
    'IQUAL': ['IQUAL'],
    'SWARRAY': ['SWARRAY_10', 'SWARRAY_15', 'SWARRAY_20', 'SWARRAY_25'],
    'SWGRAD': ['SWGRAD'],
    'DNS': ['DNS'],
    'DNSV': ['DNSV'],
}


unit_col = {
    'DNS': [''],
    'MARKER': [''],
    'GR_NORM': ['GAPI'],
    'GR': ['GAPI'],
    'GR_DUAL': ['GAPI', 'GAPI'],
    'GR_DUAL_2': ['GAPI', 'GAPI'],
    'GR_RAW_NORM': ['GAPI'],
    'GR_MovingAvg_5': ['GAPI'],
    'GR_MovingAvg_10': ['GAPI'],
    'RT': ['OHMM'],
    'RT_RO': ['OHMM', 'OHMM'],
    'X_RT_RO': ['V/V'],
    'NPHI_RHOB_NON_NORM': ['V/V', 'G/C3'],
    'NPHI_RHOB': ['V/V', 'G/C3', 'V/V', 'G/C3'],
    'RHOB': ['G/C3'],
    'SW': ['DEC'],
    'PHIE_PHIT': ['V/V', 'V/V'],
    'PERM': ['mD'],
    'VCL': ['V/V'],
    'RWAPP_RW': ['OHMM', 'OHMM'],
    'X_RWA_RW': ['V/V'],
    'RT_F': ['OHMM', 'V/V'],
    'X_RT_F': ['V/V'],
    'RT_RHOB': ['OHMM', 'G/C3', 'OHMM', 'G/C3'],
    'X_RT_RHOB': ['V/V'],
    'TEST': ['V/V'],
    'CLASS': ['V/V'],
    'CTC': ['V/V'],
    'XPT': [''],
    'RT_RGSA': ['OHMM', ''],
    'NPHI_NGSA': ['V/V', ''],
    'RHOB_DGSA': ['G/C3', ''],
    'ZONA': [''],
    'VSH': ['V/V'],
    'SP': ['MV'],
    'VSH_LINEAR': ['V/V'],
    'VSH_DN': ['V/V'],
    'VSH_SP': ['V/V'],
    'PHIE_DEN': ['', ''],
    'PHIT_DEN': ['', ''],
    'RESERVOIR_CLASS': [''],
    'RWA': ['OHMM', 'OHMM', 'OHMM'],
    'PHIE': [''],
    'RT_GR': ['OHMM', 'GAPI', 'OHMM', 'GAPI'],
    # 'RT_PHIE':['OHMM','','OHMM',''],
    'RT_PHIE': ['OHMM', ''],
    'RGBE': [''],
    'RPBE': [''],
    'RGBE_TEXT': [''],
    'RPBE_TEXT': [''],
    'IQUAL': [''],
    'SWARRAY': ['V/V', 'V/V', 'V/V', 'V/V'],
    'SWGRAD': ['V/V'],
    'DNSV': [''],
    'DNS': [''],
}


color_col = {
    'DNS': ['darkgreen'],
    'MARKER': [colors_dict['black']],
    'GR_NORM': ['orange'],
    'GR_DUAL': ['darkgreen', 'orange'],
    'GR_DUAL_2': ['darkgreen', 'orange'],
    'GR_RAW_NORM': ['orange'],
    'GR_MovingAvg_5': ['darkgreen'],
    'GR_MovingAvg_10': ['darkgreen'],
    'GR': ['darkgreen'],
    'RT': [colors_dict['red']],
    'RT_RO': [colors_dict['red'], colors_dict['purple']],
    'X_RT_RO': [colors_dict['black']],
    'NPHI_RHOB_NON_NORM': [colors_dict['blue'], colors_dict['red']],
    'NPHI_RHOB': [colors_dict['blue'], colors_dict['red'], colors_dict['blue'], colors_dict['red'],],
    'RHOB': [colors_dict['red']],
    'SW': [colors_dict['blue']],
    'PHIE_PHIT': ['darkblue', colors_dict['cyan']],
    'PERM': [colors_dict['blue']],
    'VCL': [colors_dict['black']],
    'RWAPP_RW': [colors_dict['black'], colors_dict['blue']],
    'X_RWA_RW': [colors_dict['black']],
    'RT_F': [colors_dict['red'], colors_dict['cyan']],
    'X_RT_F': [colors_dict['black']],
    'RT_RHOB': [colors_dict['red'], colors_dict['black'], colors_dict['red'], colors_dict['green']],
    'X_RT_RHOB': [colors_dict['black']],
    'TEST': [colors_dict['black']],
    'CLASS': [colors_dict['black']],
    'CTC': [colors_dict['black']],
    'XPT': [colors_dict['black']],
    'RT_RGSA': [colors_dict['red'], colors_dict['blue']],
    'NPHI_NGSA': [colors_dict['red'], colors_dict['green']],
    'RHOB_DGSA': [colors_dict['red'], colors_dict['green']],
    'ZONA': [colors_dict['black']],
    'VSH': ['darkblue'],
    'SP': ['darkblue'],
    'VSH_LINEAR': ['darkblue'],
    'VSH_DN': ['darkblue'],
    'VSH_SP': ['darkblue'],
    'PHIE_DEN': ['darkblue', colors_dict['blue']],
    'PHIT_DEN': [colors_dict['red'], colors_dict['orange']],
    'RESERVOIR_CLASS': [colors_dict['black']],
    'RWA': ['darkblue', 'darkgreen', colors_dict['red']],
    'PHIE': ['darkblue'],
    'RT_GR': [colors_dict['red'], 'darkgreen', colors_dict['red'], 'darkgreen'],
    # 'RT_PHIE':[colors_dict['red'],'darkblue',colors_dict['red'],'darkblue'],
    'RT_PHIE': [colors_dict['red'], 'darkblue'],
    'RGBE': [colors_dict['black']],
    'RPBE': [colors_dict['black']],
    'RGBE_TEXT': [colors_dict['black']],
    'RPBE_TEXT': [colors_dict['black']],
    'IQUAL': [colors_dict['black']],
    'SWARRAY': ['darkblue', 'orange', 'red', 'green'],
    'SWGRAD': ['darkgreen'],
    'DNS': [colors_dict['black']],
    'DNSV': [colors_dict['black']],
}

flag_color = {
    "TEST": {
        0: 'rgba(0,0,0,0)',
        1: colors_dict['cyan'],
        3: colors_dict['green']
    },
    "CLASS": {
        0: '#d9d9d9',
        1: '#00bfff',
        2: '#ffb6c1',
        3: '#a020f0',
        4: '#ffa600',
        5: '#8b1a1a',
        6: '#000000'
    },
    "ZONA": {
        3: colors_dict['red'],
        2: colors_dict['orange'],
        1: 'yellow',
        0: colors_dict['black'],
    },
    "RESERVOIR_CLASS": {
        4: 'green',
        3: 'yellow',
        2: 'orange',
        1: 'black',
        0: 'gray'
    },
    "IQUAL": {
        1: 'green',
    }

}

range_col = {
    'GR': [[0, 250]],
    'GR_NORM': [[0, 250]],
    'GR_DUAL': [[0, 250], [0, 250]],
    'GR_DUAL_2': [[0, 250], [0, 250]],
    'GR_RAW_NORM': [[0, 250]],
    'GR_MovingAvg_5': [[0, 250]],
    'GR_MovingAvg_10': [[0, 250]],
    'RT': [[0.02, 2000]],
    'RT_RO': [[0.02, 2000], [0.02, 2000]],
    'X_RT_RO': [[0, 4]],
    'NPHI_RHOB_NON_NORM': [[0.6, 0], [1.71, 2.71]],
    'NPHI_RHOB': [[0.6, 0], [1.71, 2.71], [1, 0], [1, 0]],
    'RHOB': [[1.71, 2.71]],
    'SW': [[1, 0]],
    'PHIE_PHIT': [[0.5, 0], [0.5, 0]],
    'PERM': [[0.02, 2000]],
    'VCL': [[0, 1]],
    'RWAPP_RW': [[0.01, 1000], [0.01, 1000]],
    'X_RWA_RW': [[0, 4]],
    'RT_F': [[0.02, 2000], [0.02, 2000]],
    'X_RT_F': [[0, 2]],
    'RT_RHOB': [[0.01, 1000], [1.71, 2.71], [0, 1], [0, 1]],
    'X_RT_RHOB': [[-0.5, 0.5]],
    'XPT': [[0, 1]],
    'RT_RGSA': [[0.02, 2000], [0.02, 2000]],
    'NPHI_NGSA': [[0.6, 0], [0.6, 0]],
    'RHOB_DGSA': [[1.71, 2.71], [1.71, 2.71]],
    'VSH': [[0, 1]],
    'SP': [[-160, 40]],
    'VSH_LINEAR': [[0, 1]],
    'VSH_DN': [[0, 1]],
    'VSH_SP': [[0, 1]],
    'PHIE_DEN': [[0, 1], [0, 1]],
    'PHIT_DEN': [[0, 1], [0, 1]],
    'RWA': [[0, 60], [0, 60], [0, 60]],
    'PHIE': [[0.6, 0]],  # perbaiki seluruh PHIE dan PHIT
    'RT_GR': [[0.02, 2000], [0, 250], [0.02, 2000], [0, 250]],
    # 'RT_PHIE':[[0.02, 2000],[0.6,0],[0.02, 2000],[0.6,0]],
    'RT_PHIE': [[0.02, 2000], [0.6, 0]],
    'SWARRAY': [[1, 0], [1, 0], [1, 0], [1, 0]],
    'SWGRAD': [[0, 0.1]],
    'DNS': [[-1, 1]],
    'DNSV': [[-1, 1]],
}

ratio_plots = {
    'MARKER': 0.5,
    'GR': 1,
    'GR_NORM': 1,
    'GR_DUAL': 1,
    'GR_DUAL_2': 1,
    'GR_RAW_NORM': 1,
    'GR_MovingAvg_5': 1,
    'GR_MovingAvg_10': 1,
    'RT': 0.5,
    'RT_RO': 1,
    'X_RT_RO': 0.5,
    'NPHI_RHOB_NON_NORM': 1,
    'NPHI_RHOB': 1,
    'RHOB': 1,
    'SW': 1,
    'PHIE_PHIT': 1,
    'PERM': 1,
    'VCL': 1,
    'RWAPP_RW': 1,
    'X_RWA_RW': 0.5,
    'RT_F': 1,
    'X_RT_F': 0.5,
    'RT_RHOB': 1,
    'X_RT_RHOB': 0.5,
    'TEST': 0.5,
    'CLASS': 0.5,
    'CTC': 0.5,
    'XPT': 1,
    'RT_RGSA': 1,
    'NPHI_NGSA': 1,
    'RHOB_DGSA': 1,
    'ZONA': 1,
    'VSH': 1,
    'SP': 1,
    'VSH_LINEAR': 1,
    'VSH_DN': 1,
    'VSH_SP': 1,
    'PHIE_DEN': 1,
    'PHIT_DEN': 1,
    'RESERVOIR_CLASS': 0.5,
    'RWA': 1,
    'PHIE': 1,
    'RT_GR': 1,
    'RT_PHIE': 1,
    'RGBE': 0.5,
    'RPBE': 0.5,
    'RGBE_TEXT': 0.5,
    'RPBE_TEXT': 0.5,
    'IQUAL': 0.5,
    'SWARRAY': 1,
    'SWGRAD': 0.5,
    'DNS': 1,
    'DNSV': 1,
}

flags_name = {
    'TEST': {
        0: "",
        1: 'Water',
        3: 'Gas'
    },
    'CLASS': {
        0: 'Non Reservoir',
        1: 'Water',
        2: 'LRLC-Potential',
        3: 'LRLC-Proven',
        4: 'LC-Res',
        5: 'Non-LCRes',
        6: 'Coal'
    },
    'ZONA': {
        0: 'Zona Prospek Kuat',
        1: 'Zona Menarik',
        2: 'Zona Lemah',
        3: 'Non Prospek',
    },
    'RESERVOIR_CLASS': {
        0: 'Zona Prospek Kuat',
        1: 'Zona Menarik',
        2: 'Zona Lemah',
        3: 'Non Prospek',
        4: 'No Data'
    },
    'IQUAL': {
        1: '1'
    }
}

thres = {
    'X_RT_RO': 1,
    'X_RWA_RW': 1.4,
    'X_RT_F': 0.7,
    'X_RT_RHOB': 0.02
}

line_width = 0.9

# ----------------------------- Plot Function ------------------------------


def discrete_colorscale(bvals, colors):
    """
    bvals - list of values bounding intervals/ranges of interest
    colors - list of rgb or hex colorcodes for values in [bvals[k], bvals[k+1]],0<=k < len(bvals)-1
    returns the plotly  discrete colorscale
    """
    if len(bvals) != len(colors)+1:
        raise ValueError(
            'len(boundary values) should be equal to  len(colors)+1')
    bvals = sorted(bvals)
    nvals = [(v-bvals[0])/(bvals[-1]-bvals[0])
             for v in bvals]  # normalized values

    dcolorscale = []  # discrete colorscale
    for k in range(len(colors)):
        dcolorscale.extend([[nvals[k], colors[k]], [nvals[k+1], colors[k]]])
    return dcolorscale


def fillcol(label, yc='rgba(0,250,0,0.4)', nc='rgba(250,0,0,0)'):
    if label >= 1:
        return yc
    else:
        return nc


def xover_label_df(df_well, key, type=1):
    if key in ['X_RT_RO', 'X_RWA_RW', 'X_RT_F', 'X_RT_RHOB']:
        xover_df = pd.DataFrame(df_well[data_col[key]].copy())
        xover_df['thres'] = [thres[key]]*len(xover_df)
        xover_df['label'] = np.where(
            df_well[data_col[key][0]] > thres[key], 1, 0)

    elif key == 'NPHI_RHOB' or key == 'RT_RHOB':
        xover_df = pd.DataFrame(df_well[data_col[key]].copy())
        xover_df['label'] = np.where(
            xover_df[data_col[key][2]] > xover_df[data_col[key][3]], 1, 0)

    else:
        xover_df = pd.DataFrame(df_well[data_col[key]].copy())
        xover_df['label'] = np.where(
            xover_df[data_col[key][0]] > xover_df[data_col[key][1]], 1, 0)

    xover_df[depth] = df_well[depth]
    xover_df['group'] = xover_df['label'].ne(
        xover_df['label'].shift()).cumsum()
    xover_df = xover_df.groupby('group')
    xover_dfs = []

    for _, data in xover_df:
        if type == 1:
            if data['label'].reset_index(drop=True)[0]:
                xover_dfs.append(data)
            else:
                continue
        else:
            xover_dfs.append(data)
    return xover_dfs


def plot_line(df_well, fig, axes, base_key, n_seq, type=None, col=None, label=None):
    """
    Plot a line curve on the well log plot.

    Parameters:
    -----------
    df_well : pandas DataFrame
        DataFrame containing well log data
    fig : plotly Figure object
        Figure to add trace to
    axes : dict
        Dictionary with axes information
    key : str
        Key for display settings (colors, ranges, units)
    n_seq : int
        Sequence number for the plot
    type : str, optional
        Plot type, if 'log' then logarithmic scale
    col : str, optional
        Column name in df_well to plot (if None, uses data_col[key][0])
    label : str, optional
        Label to display for the curve (if None, uses col)

    Returns:
    --------
    fig : plotly Figure object
        Updated figure
    axes : dict
        Updated axes dictionary
    """
    # If col is not provided, use the default column for the key
    if col is None:
        col = data_col[base_key][0]

    # If label is not provided, use the column name
    if label is None:
        label = col

    # Add trace to figure
    fig.add_trace(
        go.Scattergl(
            x=df_well[col],
            y=df_well[depth],
            line=dict(color=color_col[base_key][0], width=line_width),
            name=label,  # Use the provided label
            legend=legends[n_seq-1],
            showlegend=True,
            xaxis='x'+str(n_seq),
            yaxis='y'+str(n_seq),
        ),
    )

    # Update x-axis layout
    xaxis = "xaxis"+str(n_seq)
    if type is None:
        fig.update_layout(
            **{xaxis: dict(
                side="top",
                range=range_col[base_key][0]
            )}
        )
    else:
        fig.update_layout(
            **{xaxis: dict(
                side="top",
                type="log",
                range=[np.log10(range_col[base_key][0][0]),
                       np.log10(range_col[base_key][0][1])]
            )}
        )

    # Update axes dictionary
    axes[col].append('yaxis'+str(n_seq))
    axes[col].append('xaxis'+str(n_seq))

    return fig, axes


def plot_fill_x_to_int(df_well, fig, axes, key, n_seq, index):
    col = data_col[key][index]
    t_g = range_col[key][index][1]

    x_g = [t_g for x in df_well[col]]
    fig.add_trace(
        go.Scatter(x=x_g, y=df_well[depth],
                   line=dict(color='rgba(0,0,0,0)', width=0),
                   showlegend=False,
                   name='dummy'+col,
                   hoverinfo="skip"),
        row=1, col=n_seq)

    fig.add_trace(
        go.Scatter(
            x=df_well[col],
            y=df_well[depth],
            line=dict(color=color_col[key][index], width=line_width),
            name=col,
            legend=legends[n_seq-1],
            showlegend=True,
            fill='tonextx',
            xaxis='x'+str(n_seq),
        ),
    )

    xaxis = "xaxis"+str(n_seq)
    fig.update_layout(
        **{xaxis: dict(
            side="top",
            range=range_col[key][index]
        )}
    )

    axes[key].append('yaxis'+str(n_seq))
    axes[key].append('xaxis'+str(n_seq))

    return fig, axes


def plot_dual_gr(df_well, fig, axes, key, n_seq, counter, n_plots):
    """
    Plot dua kurva GR dan GR_NORM dalam satu plot
    """
    axes[key].append('yaxis'+str(n_seq))
    axes[key].append('xaxis'+str(n_seq))

    # Plot kurva pertama (GR)
    col1 = data_col[key][0]  # 'GR'
    fig.add_trace(
        go.Scattergl(
            x=df_well[col1],
            y=df_well[depth],
            line=dict(color=color_col[key][0], width=line_width),
            name=col1,
            legend=legends[n_seq-1],
            showlegend=True,
        ),
        row=1, col=n_seq
    )

    # Plot kurva kedua (GR_NORM) - menggunakan pola yang sama dengan fungsi lain
    counter += 1
    axes[key].append('xaxis'+str(n_plots+counter))
    col2 = data_col[key][1]  # 'GR_NORM'

    fig.add_trace(
        go.Scattergl(
            x=df_well[col2],
            y=df_well[depth],
            line=dict(color=color_col[key][1], width=line_width),
            name=col2,
            legend=legends[n_seq-1],
            showlegend=True,
            xaxis='x'+str(n_plots+counter),
            yaxis='y'+str(n_seq),
        ),
    )

    # Konfigurasi axis pertama
    xaxis1 = "xaxis"+str(n_seq)
    fig.update_layout(
        **{xaxis1: dict(
            side="top",
            range=range_col[key][0]
        )}
    )

    # Konfigurasi axis kedua (overlay)
    xaxis2 = "xaxis"+str(n_plots+counter)
    fig.update_layout(
        **{xaxis2: dict(
            overlaying='x'+str(n_seq),
            side="top",
            range=range_col[key][1]
        )}
    )

    return fig, axes, counter


def plot_gsa_crossover(df_well, fig, axes, key, n_seq, counter, n_plots, fill_color_red='red', fill_color_blue=colors_dict['blue']):
    axes[key].append('yaxis'+str(n_seq))
    axes[key].append('xaxis'+str(n_seq))

    # Tentukan kondisi fill berdasarkan jenis GSA
    if key == 'RT_RGSA':
        condition_red = df_well[data_col[key][0]
                                ] > df_well[data_col[key][1]]  # RT > RGSA (MERAH)
        condition_blue = df_well[data_col[key][0]
                                 ] < df_well[data_col[key][1]]  # RT < RGSA (BIRU)
        log_scale = True
    elif key == 'NPHI_NGSA':
        # NPHI < NGSA (MERAH)
        condition_red = df_well[data_col[key][0]] < df_well[data_col[key][1]]
        # NPHI > NGSA (BIRU)
        condition_blue = df_well[data_col[key][0]] > df_well[data_col[key][1]]
        log_scale = False
    elif key == 'RHOB_DGSA':
        # RHOB < DGSA (MERAH)
        condition_red = df_well[data_col[key][0]] < df_well[data_col[key][1]]
        # RHOB > DGSA (BIRU)
        condition_blue = df_well[data_col[key][0]] > df_well[data_col[key][1]]
        log_scale = False

    # Plot kurva utama terlebih dahulu
    fig.add_trace(
        go.Scattergl(
            x=df_well[data_col[key][0]],
            y=df_well[depth],
            line=dict(color=color_col[key][0], width=line_width),
            name=data_col[key][0],
            legend=legends[n_seq-1],
            showlegend=True,
            xaxis='x'+str(n_seq),
            yaxis='y'+str(n_seq),
        )
    )

    # Setup axis kedua untuk kurva baseline
    counter += 1
    axes[key].append('xaxis'+str(n_plots+counter))

    fig.add_trace(
        go.Scattergl(
            x=df_well[data_col[key][1]],
            y=df_well[depth],
            line=dict(color=color_col[key][1], width=line_width),
            name=data_col[key][1],
            legend=legends[n_seq-1],
            showlegend=True,
            xaxis='x'+str(n_plots+counter),
            yaxis='y'+str(n_seq),
        )
    )

    # Setup axis ketiga untuk crossover fill RED
    counter += 1
    axes[key].append('xaxis'+str(n_plots+counter))

    # Setup axis keempat untuk crossover fill BLUE
    counter += 1
    axes[key].append('xaxis'+str(n_plots+counter))

    # Buat DataFrame untuk crossover RED
    xover_red_df = pd.DataFrame({
        data_col[key][0]: df_well[data_col[key][0]],
        data_col[key][1]: df_well[data_col[key][1]],
        depth: df_well[depth],
        'label_red': condition_red.astype(int)
    })

    # Buat DataFrame untuk crossover BLUE
    xover_blue_df = pd.DataFrame({
        data_col[key][0]: df_well[data_col[key][0]],
        data_col[key][1]: df_well[data_col[key][1]],
        depth: df_well[depth],
        'label_blue': condition_blue.astype(int)
    })

    # Group berdasarkan perubahan label RED
    xover_red_df['group'] = xover_red_df['label_red'].ne(
        xover_red_df['label_red'].shift()).cumsum()
    xover_red_groups = xover_red_df.groupby('group')

    # Plot area fill RED untuk setiap group yang memenuhi kondisi
    for _, group_data in xover_red_groups:
        if group_data['label_red'].iloc[0] == 1:
            # Baseline (invisible line)
            fig.add_trace(
                go.Scatter(
                    x=group_data[data_col[key][0]],
                    y=group_data[depth],
                    name='baseline_red',
                    showlegend=False,
                    line=dict(color='rgba(0,0,0,0)', width=0),
                    xaxis='x'+str(n_plots+counter-1),  # GUNAKAN AXIS KETIGA
                    yaxis='y'+str(n_seq),
                    hoverinfo="skip"
                )
            )

            # Fill area RED (tonextx)
            fig.add_trace(
                go.Scatter(
                    x=group_data[data_col[key][1]],
                    y=group_data[depth],
                    line=dict(color='rgba(0,0,0,0)', width=0),
                    name='fill_area_red',
                    fill='tonextx',
                    showlegend=False,
                    fillcolor=fill_color_red,
                    # GUNAKAN AXIS KETIGA YANG SAMA
                    xaxis='x'+str(n_plots+counter-1),
                    yaxis='y'+str(n_seq),
                    hoverinfo="skip"
                )
            )

    # Group berdasarkan perubahan label BLUE
    xover_blue_df['group'] = xover_blue_df['label_blue'].ne(
        xover_blue_df['label_blue'].shift()).cumsum()
    xover_blue_groups = xover_blue_df.groupby('group')

    # Plot area fill BLUE untuk setiap group yang memenuhi kondisi
    for _, group_data in xover_blue_groups:
        if group_data['label_blue'].iloc[0] == 1:
            # Baseline (invisible line)
            fig.add_trace(
                go.Scatter(
                    x=group_data[data_col[key][0]],
                    y=group_data[depth],
                    name='baseline_blue',
                    showlegend=False,
                    line=dict(color='rgba(0,0,0,0)', width=0),
                    xaxis='x'+str(n_plots+counter),  # GUNAKAN AXIS KEEMPAT
                    yaxis='y'+str(n_seq),
                    hoverinfo="skip"
                )
            )

            # Fill area BLUE (tonextx)
            fig.add_trace(
                go.Scatter(
                    x=group_data[data_col[key][1]],
                    y=group_data[depth],
                    line=dict(color='rgba(0,0,0,0)', width=0),
                    name='fill_area_blue',
                    fill='tonextx',
                    showlegend=False,
                    fillcolor=fill_color_blue,
                    # GUNAKAN AXIS KEEMPAT YANG SAMA
                    xaxis='x'+str(n_plots+counter),
                    yaxis='y'+str(n_seq),
                    hoverinfo="skip"
                )
            )

    # Update axis layout untuk axis pertama
    xaxis1 = "xaxis"+str(n_seq)
    if log_scale:
        fig.update_layout(
            **{xaxis1: dict(
                side="top",
                type="log",
                range=[np.log10(range_col[key][0][0]),
                       np.log10(range_col[key][0][1])]
            )}
        )
    else:
        fig.update_layout(
            **{xaxis1: dict(
                side="top",
                range=range_col[key][0]
            )}
        )

    # Update axis layout untuk axis kedua (baseline curve)
    xaxis2 = "xaxis"+str(n_plots+counter-2)
    if log_scale and len(range_col[key]) > 1:
        fig.update_layout(
            **{xaxis2: dict(
                overlaying='x'+str(n_seq),
                side="top",
                type="log",
                range=[np.log10(range_col[key][1][0]),
                       np.log10(range_col[key][1][1])]
            )}
        )
    elif len(range_col[key]) > 1:
        fig.update_layout(
            **{xaxis2: dict(
                overlaying='x'+str(n_seq),
                side="top",
                range=range_col[key][1]
            )}
        )

    # Update axis layout untuk axis ketiga (crossover fill RED) - INVISIBLE
    xaxis3 = "xaxis"+str(n_plots+counter-1)
    # Gunakan range yang sesuai untuk fill area
    fill_range = range_col[key][0] if len(range_col[key]) > 0 else [0, 1]

    if log_scale:
        fig.update_layout(
            **{xaxis3: dict(
                visible=False,
                overlaying='x'+str(n_seq),
                side="top",
                type="log",
                range=[np.log10(fill_range[0]), np.log10(fill_range[1])]
            )}
        )
    else:
        fig.update_layout(
            **{xaxis3: dict(
                visible=False,
                overlaying='x'+str(n_seq),
                side="top",
                range=fill_range
            )}
        )

    # Update axis layout untuk axis keempat (crossover fill BLUE) - INVISIBLE
    xaxis4 = "xaxis"+str(n_plots+counter)

    if log_scale:
        fig.update_layout(
            **{xaxis4: dict(
                visible=False,
                overlaying='x'+str(n_seq),
                side="top",
                type="log",
                range=[np.log10(fill_range[0]), np.log10(fill_range[1])]
            )}
        )
    else:
        fig.update_layout(
            **{xaxis4: dict(
                visible=False,
                overlaying='x'+str(n_seq),
                side="top",
                range=fill_range
            )}
        )

    return fig, axes, counter


def plot_two_features_simple(df_well, fig, axes, key, n_seq, counter, n_plots, log_scale=False):
    """
    Plot dua feature dengan dual x-axis untuk range yang berbeda.
    Feature kedua menggunakan x-axis overlay dengan garis putus-putus.
    """

    # Tambahkan axis info ke dictionary
    axes[key].append('yaxis'+str(n_seq))
    axes[key].append('xaxis'+str(n_seq))

    # Plot kurva pertama (solid line) - menggunakan axis pertama
    fig.add_trace(
        go.Scattergl(
            x=df_well[data_col[key][0]],
            y=df_well[depth],
            line=dict(
                color=color_col[key][0],
                width=line_width
            ),
            name=data_col[key][0],
            legend=legends[n_seq-1],
            showlegend=True,
            xaxis='x'+str(n_seq),
            yaxis='y'+str(n_seq),
        )
    )

    # PERBAIKAN: Increment counter dan tambah axis kedua ke dictionary
    counter += 1
    axes[key].append('xaxis'+str(n_plots+counter))

    # Plot kurva kedua (dashed line) - menggunakan axis kedua
    fig.add_trace(
        go.Scattergl(
            x=df_well[data_col[key][1]],
            y=df_well[depth],
            line=dict(
                color=color_col[key][1],
                width=line_width,
                # dash='dash'
            ),
            name=data_col[key][1],
            legend=legends[n_seq-1],
            showlegend=True,
            xaxis='x'+str(n_plots+counter),  # PERBAIKAN: Gunakan axis kedua
            yaxis='y'+str(n_seq),
        )
    )

    # Update axis layout untuk axis pertama
    xaxis1 = "xaxis"+str(n_seq)
    if log_scale:
        fig.update_layout(
            **{xaxis1: dict(
                side="top",
                type="log",
                range=[np.log10(range_col[key][0][0]),
                       np.log10(range_col[key][0][1])]
            )}
        )
    else:
        fig.update_layout(
            **{xaxis1: dict(
                side="top",
                range=range_col[key][0]
            )}
        )

    # Update axis layout untuk axis kedua (overlay)
    xaxis2 = "xaxis"+str(n_plots+counter)
    if log_scale and len(range_col[key]) > 1:
        fig.update_layout(
            **{xaxis2: dict(
                overlaying='x'+str(n_seq),
                side="top",
                type="log",
                range=[np.log10(range_col[key][1][0]),
                       np.log10(range_col[key][1][1])]
            )}
        )
    elif len(range_col[key]) > 1:
        fig.update_layout(
            **{xaxis2: dict(
                overlaying='x'+str(n_seq),
                side="top",
                range=range_col[key][1]
            )}
        )

    return fig, axes, counter


def plot_three_features_simple(df_well, fig, axes, key, n_seq, counter, n_plots, log_scale=False):
    """
    Plot tiga feature dengan triple x-axis untuk range yang berbeda.
    Feature kedua dan ketiga menggunakan x-axis overlay dengan garis putus-putus dan titik-titik.
    """

    # Tambahkan axis info ke dictionary untuk feature pertama
    axes[key].append('yaxis'+str(n_seq))
    axes[key].append('xaxis'+str(n_seq))

    # Plot kurva pertama (solid line) - menggunakan axis pertama
    fig.add_trace(
        go.Scattergl(
            x=df_well[data_col[key][0]],
            y=df_well[depth],
            line=dict(
                color=color_col[key][0],
                width=line_width
            ),
            name=data_col[key][0],
            legend=legends[n_seq-1],
            showlegend=True,
            xaxis='x'+str(n_seq),
            yaxis='y'+str(n_seq),
        )
    )

    # PERBAIKAN: Increment counter dan tambah axis kedua ke dictionary
    counter += 1
    axes[key].append('xaxis'+str(n_plots+counter))

    # Plot kurva kedua (dashed line) - menggunakan axis kedua
    fig.add_trace(
        go.Scattergl(
            x=df_well[data_col[key][1]],
            y=df_well[depth],
            line=dict(
                color=color_col[key][1],
                width=line_width,
                dash='dash'
            ),
            name=data_col[key][1],
            legend=legends[n_seq-1],
            showlegend=True,
            xaxis='x'+str(n_plots+counter),
            yaxis='y'+str(n_seq),
        )
    )

    # PERBAIKAN: Increment counter lagi dan tambah axis ketiga ke dictionary
    counter += 1
    axes[key].append('xaxis'+str(n_plots+counter))

    # Plot kurva ketiga (dotted line) - menggunakan axis ketiga
    fig.add_trace(
        go.Scattergl(
            x=df_well[data_col[key][2]],
            y=df_well[depth],
            line=dict(
                color=color_col[key][2],
                width=line_width,
                dash='dot'
            ),
            name=data_col[key][2],
            legend=legends[n_seq-1],
            showlegend=True,
            xaxis='x'+str(n_plots+counter),
            yaxis='y'+str(n_seq),
        )
    )

    # Update axis layout untuk axis pertama
    xaxis1 = "xaxis"+str(n_seq)
    if log_scale:
        fig.update_layout(
            **{xaxis1: dict(
                side="top",
                type="log",
                range=[np.log10(range_col[key][0][0]),
                       np.log10(range_col[key][0][1])]
            )}
        )
    else:
        fig.update_layout(
            **{xaxis1: dict(
                side="top",
                range=range_col[key][0]
            )}
        )

    # Update axis layout untuk axis kedua (overlay)
    # counter-1 karena sudah di-increment
    xaxis2 = "xaxis"+str(n_plots+counter-1)
    if log_scale and len(range_col[key]) > 1:
        fig.update_layout(
            **{xaxis2: dict(
                overlaying='x'+str(n_seq),
                side="top",
                type="log",
                range=[np.log10(range_col[key][1][0]),
                       np.log10(range_col[key][1][1])]
            )}
        )
    elif len(range_col[key]) > 1:
        fig.update_layout(
            **{xaxis2: dict(
                overlaying='x'+str(n_seq),
                side="top",
                range=range_col[key][1]
            )}
        )

    # Update axis layout untuk axis ketiga (overlay)
    xaxis3 = "xaxis"+str(n_plots+counter)
    if log_scale and len(range_col[key]) > 2:
        fig.update_layout(
            **{xaxis3: dict(
                overlaying='x'+str(n_seq),
                side="top",
                type="log",
                range=[np.log10(range_col[key][2][0]),
                       np.log10(range_col[key][2][1])]
            )}
        )
    elif len(range_col[key]) > 2:
        fig.update_layout(
            **{xaxis3: dict(
                overlaying='x'+str(n_seq),
                side="top",
                range=range_col[key][2]
            )}
        )

    return fig, axes, counter


def plot_four_features_simple(df_well, fig, axes, key, n_seq, counter, n_plots, log_scale=False):
    """
    Plot empat feature dengan semua garis solid (tidak putus-putus).
    Semua menggunakan overlay x-axis dengan range yang berbeda.
    """

    # Tambahkan axis info ke dictionary
    axes[key].append('yaxis'+str(n_seq))
    axes[key].append('xaxis'+str(n_seq))

    # Plot semua 4 kurva dengan loop
    for i in range(4):
        # Plot kurva
        fig.add_trace(
            go.Scattergl(
                x=df_well[data_col[key][i]],
                y=df_well[depth],
                line=dict(
                    color=color_col[key][i],
                    width=line_width
                ),
                name=data_col[key][i],
                legend=legends[n_seq-1],
                showlegend=True,
                xaxis='x'+str(n_seq if i == 0 else n_plots+counter+i),
                yaxis='y'+str(n_seq),
            )
        )

        # Tambah axis ke dictionary (kecuali yang pertama, sudah ditambah di atas)
        if i > 0:
            axes[key].append('xaxis'+str(n_plots+counter+i))

    # Setup axis layout untuk semua 4 axis
    for i in range(4):
        if i == 0:
            # Axis pertama (main axis)
            xaxis_name = "xaxis"+str(n_seq)
            axis_config = dict(
                side="top",
                range=range_col[key][0]
            )
        else:
            # Axis overlay
            xaxis_name = "xaxis"+str(n_plots+counter+i)
            axis_config = dict(
                overlaying='x'+str(n_seq),
                side="top",
                range=range_col[key][i] if len(
                    range_col[key]) > i else range_col[key][0]
            )

        # Apply log scale jika diperlukan
        if log_scale and len(range_col[key]) > i:
            axis_config.update({
                "type": "log",
                "range": [np.log10(range_col[key][i][0]), np.log10(range_col[key][i][1])]
            })

        fig.update_layout(**{xaxis_name: axis_config})

    # Update counter
    # Tambah 3 karena menambah 3 axis baru (yang pertama sudah ada)
    counter += 3

    return fig, axes, counter


def plot_xover(df_well, fig, axes, key, n_seq, counter, n_plots, y_color='limegreen', n_color='lightgray'):
    axes[key].append('yaxis'+str(n_seq))
    axes[key].append('xaxis'+str(n_seq))

    # Plot Area Xover
    xover_dfs = xover_label_df(df_well, key, type=1)
    for xover_df in xover_dfs:
        fig.add_traces(
            go.Scatter(
                x=xover_df[data_col[key][0]],
                y=xover_df[depth],
                name='xover',
                showlegend=False,
                line=dict(color='rgba(0,0,0,0)', width=0),
                xaxis='x'+str(n_seq),
                yaxis='y'+str(n_seq),
                hoverinfo="skip"
            ),
        )

        fig.add_traces(
            go.Scatter(
                x=xover_df[data_col[key][1]],
                y=xover_df[depth],
                line=dict(color='rgba(0,0,0,0)', width=0),
                name='xover',
                fill='tonextx',
                showlegend=False,
                fillcolor=fillcol(xover_df['label'].iloc[0], y_color, n_color),
                xaxis='x'+str(n_seq),
                yaxis='y'+str(n_seq),
                hoverinfo="skip"
            ),
        )

    # Plot Line
    col = data_col[key][0]
    fig.add_trace(
        go.Scattergl(
            x=df_well[col],
            y=df_well[depth],
            line=dict(color=color_col[key][0], width=line_width),
            name=col,
            legend=legends[n_seq-1],
            showlegend=True,
        ),
        row=1, col=n_seq,
    )

    col = data_col[key][1]
    fig.add_trace(
        go.Scattergl(
            x=df_well[col],
            y=df_well[depth],
            line=dict(color=color_col[key][1], width=line_width),
            name=col,
            legend=legends[n_seq-1],
            showlegend=True,
        ),
        row=1, col=n_seq,
    )

    axis = 'xaxis'+str(n_seq)
    fig.update_layout(
        **{axis: dict(
            side="top",
            type="log",
            range=[np.log10(range_col[key][0][0]),
                   np.log10(range_col[key][0][1])]
        )})

    counter += 1
    axes[key].append('xaxis'+str(n_plots+counter))
    fig.add_trace(
        go.Scatter(
            x=[], y=[],
            line=dict(color="rgba(0,0,0,0)", width=0),
            name=col,
            legend=legends[n_seq-1],
            showlegend=False,
            hoverinfo="skip",
            xaxis='x'+str(n_plots+counter),
            yaxis='y'+str(n_seq),
        ),
    )

    axis = 'xaxis'+str(n_plots+counter)
    fig.update_layout(
        **{axis: dict(
            overlaying='x'+str(n_seq),
            side="top",
            type="log",
            range=[np.log10(range_col[key][0][0]),
                   np.log10(range_col[key][0][1])]
        )})

    return fig, axes, counter


def plot_xover_thres(df_well, fig, axes, key, n_seq, counter, y_color=colors_dict['red'], n_color='lightgray'):
    axes[key].append('yaxis'+str(n_seq))
    axes[key].append('xaxis'+str(n_seq))

    # Plot Area Xover
    xover_dfs = xover_label_df(df_well, key, type=1)
    for xover_df in xover_dfs:
        fig.add_traces(
            go.Scatter(
                x=xover_df[data_col[key][0]],
                y=xover_df[depth],
                name='xover',
                showlegend=False,
                line=dict(color='rgba(0,0,0,0)', width=0),
                xaxis='x'+str(n_seq),
                yaxis='y'+str(n_seq),
                hoverinfo="skip"
            ),
        )

        fig.add_traces(
            go.Scatter(
                x=xover_df['thres'],
                y=xover_df[depth],
                line=dict(color='rgba(0,0,0,0)', width=0),
                name='xover',
                fill='tonextx',
                showlegend=False,
                fillcolor=fillcol(xover_df['label'].iloc[0], y_color, n_color),
                xaxis='x'+str(n_seq),
                yaxis='y'+str(n_seq),
                hoverinfo="skip"
            ),
        )

    # Plot Line
    col = data_col[key][0]
    fig.add_trace(
        go.Scattergl(
            x=df_well[col],
            y=df_well[depth],
            line=dict(color=color_col[key][0], width=line_width),
            name=col,
            legend=legends[n_seq-1],
            showlegend=True,
        ),
        row=1, col=n_seq,
    )

    fig.add_trace(
        go.Scattergl(
            x=[thres[key]]*len(df_well[depth]),
            y=df_well[depth],
            line=dict(color=colors_dict['red'], width=line_width),
            name="Threshold",
            legend=legends[n_seq-1],
            showlegend=True,
        ),
        row=1, col=n_seq,
    )

    axis = 'xaxis'+str(n_seq)
    fig.update_layout(
        **{axis: dict(
            side="top",
            range=range_col[key][0]
        )})

    return fig, axes, counter


def plot_xover_log_normal(df_well, fig, axes, key, n_seq, counter, n_plots, y_color='limegreen', n_color='lightgray', type=1, exclude_crossover=False):
    axes[key] = ['yaxis'+str(n_seq), 'xaxis'+str(n_seq)]  # Initialize
    col = data_col[key][0]
    range_type = 'log' if col == 'RT' else "-"
    range_axis = [np.log10(range_col[key][0][0]), np.log10(
        range_col[key][0][1])] if range_type == 'log' else range_col[key][0]
    fig.add_trace(go.Scattergl(x=df_well[col], y=df_well[depth], line=dict(
        color=color_col[key][0], width=line_width), name=col, legend=legends[n_seq-1], showlegend=False), row=1, col=n_seq)
    fig.update_layout(
        **{"xaxis"+str(n_seq): dict(side="top", type=range_type, range=range_axis)})

    counter += 1
    axes[key].append('xaxis'+str(n_plots+counter))
    col = data_col[key][1]
    range_type = 'log' if col == 'RT' else "-"
    range_axis = [np.log10(range_col[key][1][0]), np.log10(
        range_col[key][1][1])] if range_type == 'log' else range_col[key][1]
    fig.add_trace(go.Scattergl(x=df_well[col], y=df_well[depth], line=dict(color=color_col[key][1], width=line_width),
                  name=col, legend=legends[n_seq-1], showlegend=False, xaxis='x'+str(n_plots+counter), yaxis='y'+str(n_seq)))
    fig.update_layout(**{"xaxis"+str(n_plots+counter): dict(overlaying="x" +
                      str(n_seq), side="top", type=range_type, range=range_axis)})

    if not exclude_crossover:
        counter += 1
        axes[key].append('xaxis'+str(n_plots+counter))
        xover_dfs = xover_label_df(df_well, key, type=type)
        for xover_df in xover_dfs:
            fig.add_traces(go.Scatter(x=xover_df[data_col[key][2]], y=xover_df[depth], name='xover', showlegend=False, line=dict(
                color='rgba(0,0,0,0)'), xaxis='x'+str(n_plots+counter), yaxis='y'+str(n_seq), hoverinfo="skip"))
            fig.add_traces(go.Scatter(x=xover_df[data_col[key][3]], y=xover_df[depth], line=dict(color='rgba(0,0,0,0)'), name='xover', fill='tonextx', showlegend=False, fillcolor=fillcol(
                xover_df['label'].iloc[0], y_color, n_color), xaxis='x'+str(n_plots+counter), yaxis='y'+str(n_seq), hoverinfo="skip"))
        fig.update_layout(**{"xaxis"+str(n_plots+counter): dict(visible=False,
                          overlaying="x"+str(n_seq), side="top", range=range_col[key][0])})

    return fig, axes, counter


def plot_fill_x_to_zero(df_well, fig, axes, key, n_seq, index):
    col = data_col[key][index]
    fig.add_trace(
        go.Scatter(
            x=df_well[col],
            y=df_well[depth],
            line=dict(color=color_col[key][index], width=line_width),
            name=col,
            legend=legends[n_seq-1],
            showlegend=True,
            fill='tozerox',
            fillcolor='lightgray',
            xaxis='x'+str(n_seq),
            yaxis='y'+str(n_seq),
        ),
    )

    xaxis = "xaxis"+str(n_seq)
    fig.update_layout(
        **{xaxis: dict(
            side="top",
            range=range_col[key][index]
        )}
    )

    axes[key].append('yaxis'+str(n_seq))
    axes[key].append('xaxis'+str(n_seq))

    return fig, axes


def plot_n_fill_x_to_zero(df_well, fig, axes, key, n_seq, counter, n_plots):
    axes[key].append('yaxis'+str(n_seq))
    axes[key].append('xaxis'+str(n_seq))
    for ind, col in enumerate(data_col[key]):
        fig.add_trace(
            go.Scatter(
                x=df_well[col],
                y=df_well[depth],
                line=dict(color=color_col[key][ind], width=line_width),
                name=col,
                legend=legends[n_seq-1],
                showlegend=True,
                fill='tonextx',
            ),
            row=1, col=n_seq,
        )

    xaxis = "xaxis"+str(n_seq)
    fig.update_layout(
        **{xaxis: dict(
            side="top",
            range=range_col[key][0]
        )}
    )

    for j in range(1, len(data_col[key])):
        counter += 1
        fig.add_trace(
            go.Scatter(
                x=[],
                y=[],
                line=dict(color="rgba(0,0,0,0)", width=0),
                name=col,
                legend=legends[n_seq-1],
                showlegend=False,
                hoverinfo="skip",
                xaxis='x'+str(n_plots+counter),
                yaxis='y'+str(n_seq),
            ),
        )
        xaxis = "xaxis"+str(n_plots+counter)
        fig.update_layout(
            **{xaxis: dict(
                side="top",
                overlaying='x'+str(n_seq),
                range=range_col[key][0]
            )}
        )
        axes[key].append('xaxis'+str(n_plots+counter))

    return fig, axes, counter


def plot_flag(df_well, fig, axes, key, n_seq):
    col = data_col[key][0]
    if key == 'TEST':
        flag_colors = flag_color[key]
        flags_names = flags_name[key]
        max_val = 3
    elif key == 'CLASS':
        flag_colors = flag_color[key]
        flags_names = flags_name[key]
        max_val = 6
    elif key == 'ZONA':
        flag_colors = flag_color[key]
        flags_names = flags_name[key]
        max_val = 4
    elif key == 'RESERVOIR_CLASS':
        flag_colors = flag_color[key]
        flags_names = flags_name[key]
        max_val = 4
    elif key == 'IQUAL':
        flag_colors = flag_color[key]
        flags_names = flags_name[key]
        max_val = 1
    elif key == 'CTC':
        flag_colors = flag_color[key]
        flags_names = flags_name[key]
        max_val = 6
    elif key in ['MARKER', 'RGBE', 'RPBE']:
        df_well, flags_names = encode_with_nan(df_well, key)
        max_val = len(flags_names.keys())
        flag_colors = {}
        for i in range(max_val):
            flag_colors[int(i)] = generate_new_color(
                flag_colors, pastel_factor=0)

        for i in range(max_val):
            flag_colors[int(i)] = rgb_to_hex(flag_colors[int(i)])

        flag_colors[0] = 'rgba(0,0,0,0)'

    ones = np.ones((len(df_well[depth]), 1))
    arr = np.array(df_well[col]/max_val).reshape(-1, 1)
    fill = np.multiply(ones, arr)

    bvals = []
    for i in range(1, len(flag_colors.values())+2):
        bvals.append(i)
    colors = list(flag_colors.values())
    colorscale = discrete_colorscale(bvals, colors)

    custom_data = []
    flag_names = df_well[col].map(flags_names.get)
    for i in flag_names:
        custom_data.append([i]*int(max_val+1))

    fig.add_trace(
        go.Heatmap(z=fill, zmin=0, zmax=1, y=df_well[depth], name=col,
                   customdata=custom_data, colorscale=colorscale, showscale=False, hovertemplate="%{customdata}"),
        row=1, col=n_seq, )

    xaxis = "xaxis"+str(n_seq)
    xaxis = "xaxis"+str(n_seq)
    fig.update_layout(
        **{xaxis: dict(
            side="top",
            showticklabels=False,
        )}
    )

    axes[key].append('yaxis'+str(n_seq))
    axes[key].append('xaxis'+str(n_seq))

    return fig, axes


def plot_xpt(df_well, fig, axes, key, n_seq):
    fig.add_trace(
        go.Scattergl(
            x=[1]*len(df_well[depth]),
            y=df_well[depth],
            line=dict(color="rgba(0,0,0,0)", width=0),
            # name=col.split("_",1)[-1],
            # legend=legends[key-1],
            showlegend=False,
            xaxis='x'+str(n_seq),
            yaxis='y'+str(n_seq),
        ),
        # row = 1, col = key,
    )

    xaxis = "xaxis"+str(n_seq)
    fig.update_layout(
        **{xaxis: dict(
            side="top",
            range=[0, 1]
        )}
    )

    axes[key].append('yaxis'+str(n_seq))
    axes[key].append('xaxis'+str(n_seq))

    return fig, axes


def plot_texts_xpt(df_text, fig, axes, key, n_seq):
    if not df_text.empty:
        for index, row in df_text[['Depth (m)', 'Note']].iterrows():
            x = 0
            y = row['Depth (m)']
            text = row['Note'][:20]
            fig.add_annotation(
                x=x,
                y=y,
                xref="x"+str(n_seq),
                yref="y",
                xanchor='left',
                yanchor='middle',
                text=text,
                showarrow=True,
                font=dict(
                    size=10,
                    color="black"
                ),
                align="left",
                arrowhead=0,
                arrowsize=5,
                arrowwidth=1,
                arrowcolor="black",
                ax=7,
                ay=0,
            )

    return fig, axes


def plot_texts_marker(df_text, depth_btm, fig, axes, key, n_seq):
    if not df_text.empty:
        for index, row in df_text[['Mean Depth', 'Surface']].iterrows():
            x = 0
            y = row['Mean Depth']
            text = row['Surface'][:6]
            if y < depth_btm:
                fig.add_annotation(
                    x=x,
                    y=y,
                    xref="x"+str(n_seq),
                    yref="y",
                    xanchor='center',
                    yanchor='middle',
                    text=text,
                    showarrow=True,
                    font=dict(
                        size=10,
                        color="black"
                    ),
                    align="center",
                    bgcolor="white",
                    ax=0,
                    ay=0,
                )

    return fig, axes


def plot_text_values(df_text, depth_btm, fig, axes, key, n_seq):

    if not df_text.empty:
        # Membuat trace kosong untuk mendefinisikan axes
        # Menggunakan scatter plot kosong sebagai placeholder
        fig.add_trace(
            go.Scatter(
                x=[0, 1],  # range x sederhana
                y=[df_text['Mean Depth'].min(), df_text['Mean Depth'].max()
                   ],  # range y berdasarkan data
                mode='markers',
                # marker transparan
                marker=dict(size=0, color='rgba(0,0,0,0)'),
                showlegend=False,
                hoverinfo='skip'
            ),
            row=1, col=n_seq
        )

        # Menambahkan annotation untuk setiap teks
        for index, row in df_text[['Mean Depth', 'Surface']].iterrows():
            x = 0.5  # posisi x di tengah
            y = row['Mean Depth']
            text = row['Surface'][:6]  # mengambil 6 karakter pertama

            if y < depth_btm:
                fig.add_annotation(
                    x=x,
                    y=y,
                    xref="x"+str(n_seq),
                    # menggunakan yref yang sesuai dengan n_seq
                    yref="y"+str(n_seq),
                    xanchor='center',
                    yanchor='middle',
                    text=text,
                    showarrow=True,
                    font=dict(
                        size=10,
                        color="black"
                    ),
                    align="center",
                    ax=0,
                    ay=0,
                )

    # Mengatur xaxis dan yaxis
    xaxis = "xaxis"+str(n_seq)
    yaxis = "yaxis"+str(n_seq)

    fig.update_layout(
        **{xaxis: dict(
            side="top",
            showticklabels=False,
        ),
            yaxis: dict(
            showticklabels=False,
            visible=False
        )}
    )

    axes[key].append('yaxis'+str(n_seq))
    axes[key].append('xaxis'+str(n_seq))

    return fig, axes

# ---------------------------- Layout FUnction -----------------------------


def layout_range_all_axis(fig, axes, plot_sequence):
    for key, axess in axes.items():
        for axis in axess:
            # key = plot_sequence[i]
            if axis.startswith('yaxis'):
                fig.update_layout(
                    **{axis: dict(
                        domain=[0, 0.9],
                        gridcolor='gainsboro',
                        showspikes=True,
                        showgrid=True,
                        showticklabels=False if axis.startswith(
                            'xaxis') else True,
                    )}
                )
            elif key in ['RT_RO', 'PERM', 'RWAPP_RW', 'RT_F', 'RT_RHOB', 'RT_RGSA', 'RT', 'RT_GR', 'RT_PHIE']:
                a = range_col[key][0][0]
                b = range_col[key][0][1]
                n = int(np.log10(b/a))
                arr = list(np.arange(a, 0.1, 0.01))
                for j in range(n-1):
                    arr = arr + list(np.arange(10**(j-1), 10**j, 10**(j-1)))
                arr = arr + list(np.arange(1000, b+1, 1000))

                fig.update_layout(
                    **{axis: dict(
                        # gridcolor='rgba(0,0,0,0)',
                        tickvals=arr,
                        gridcolor='gainsboro',
                        side="top",
                        fixedrange=True,
                        showticklabels=False if axis.startswith(
                            'xaxis') else True,
                    )}
                )
            elif key in ['GR', 'SP', 'GR_NORM', 'GR_DUAL', 'RTRO', 'NPHI_RHOB', 'SW', 'PHIE_PHIT', 'VCL', 'X_RWA_RW', 'X_RT_F', 'X_RT_RHOB', 'NPHI_NGSA', 'RHOB_DGSA', 'VSH_LINEAR', 'VSH_DN', 'VSH_SP', 'RHOB', 'PHIE_DEN', 'PHIT_DEN', 'RWA', 'PHIE', 'DNS', 'DNSV', 'VSH']:
                fig.update_layout(
                    **{axis: dict(
                        # gridcolor='rgba(0,0,0,0)',
                        tickvals=list(np.linspace(
                            range_col[key][0][0], range_col[key][0][1], 5)),
                        gridcolor='gainsboro',
                        side="top",
                        fixedrange=True,
                        showticklabels=False if axis.startswith(
                            'xaxis') else True,
                    )}
                )
    return fig


def layout_draw_lines(fig, ratio_plots, df_well, xgrid_intv):
    # Menambahkan garis pembatas
    ratio_plots = np.array(ratio_plots)
    line_pos = []
    for i in ratio_plots:
        line_pos.append(
            i*(1/(ratio_plots/len(ratio_plots)).sum())/len(ratio_plots))
    shapes = []

    shapes.append(
        dict(
            type='line', xref='paper', yref='paper', x0=0, x1=0, y0=1, y1=0,
            line=dict(color='black', width=1, dash='solid')
        )
    )

    x = 0
    for pos in line_pos:
        x += pos
        shapes.append(
            dict(
                type='line', xref='paper', yref='paper', x0=x, x1=x, y0=1, y1=0,
                line=dict(color='black', width=1, dash='solid')
            )
        )

    for i in range(2):
        shapes.append(
            dict(
                type='line', xref='paper', yref='paper', x0=0, x1=1, y0=i, y1=i,
                line=dict(color='black', width=1, dash='solid')
            )
        )

    shapes.append(
        dict(
            type='line', xref='paper', yref='paper', x0=0, x1=1, y0=0.9, y1=0.9,
            line=dict(color='black', width=1, dash='solid')
        )
    )

    # plot grid
    if xgrid_intv is not None and xgrid_intv != 0:
        shapes = shapes + [dict(layer='below',
                                type="line",
                                x0=0, x1=1,
                                xref="paper",
                                y0=y, y1=y,
                                line=dict(color="gainsboro", width=1)) for y in range(0, int(df_well[depth].max()), xgrid_intv)]  # Setiap 2 satuan

        fig.update_layout(shapes=shapes, yaxis=dict(showgrid=False))
    else:
        fig.update_layout(shapes=shapes)

    return fig

# ---panggil layout axis


def layout_axis(fig, axes, ratio_plots, plot_sequence):
    fig.add_annotation(
        dict(font=dict(color='black', size=12),
             x=-0.001,
             y=0.97,
             xanchor="right",
             yanchor="top",
             showarrow=False,
             text=depth+' (m)',
             textangle=-90,
             xref='paper',
             yref="paper"
             )
    )
    pos_x_c = 0
    ratio_plots = np.array(ratio_plots)
    line_pos = []
    for i in ratio_plots:
        line_pos.append(
            i*(1/(ratio_plots/len(ratio_plots)).sum())/len(ratio_plots))

    pos_x_t = 0
    for i, key in enumerate(axes.keys()):
        # key = plot_sequence[i]
        pos_x = line_pos[i]
        # pos_y = 0.85
        pos_y = 0.92
        pos_x_c += 0.5*pos_x

        # Ganti dengan key yang butuh semua axis (feature di datacol)
        if key in ['SWARRAY']:
            axis_range = axes[key][1:]  # Semua axis
        else:
            axis_range = axes[key][1:3]  # Hanya 2 axis pertama

        for j, axis in enumerate(axis_range):
            # print(f'{i}:{j}')
            fig.update_layout(
                **{axis: dict(
                    tickfont=dict(color=color_col[key][j], size=9),
                    anchor="free",
                    showline=True,
                    position=pos_y,
                    showticklabels=False,
                    linewidth=1.5,
                    linecolor=color_col[key][j],
                )}
            )

            # Add Text Parameter
            fig.add_annotation(
                dict(font=dict(color=color_col[key][j], size=12),
                     # x=x_loc,
                     x=pos_x_c,
                     y=pos_y,
                     xanchor="center",
                     yanchor="bottom",
                     showarrow=False,
                     text=data_col[key][j],
                     textangle=0,
                     xref='paper',
                     yref="paper"
                     )
            )

            # Add Text Unit
            fig.add_annotation(
                dict(font=dict(color=color_col[key][j], size=10),
                     x=pos_x_c,
                     y=pos_y,
                     xanchor="center",
                     yanchor="top",
                     showarrow=False,
                     text=unit_col[key][j],
                     textangle=0,
                     xref='paper',
                     yref="paper"
                     )
            )

            # Add Text Min Max Range
            if key not in ['CLASS', 'TEST', 'XPT', 'MARKER', 'ZONA', 'RESERVOIR_CLASS', 'RGBE', 'RPBE', 'IQUAL', 'RGBE_TEXT', 'RPBE_TEXT']:
                fig.add_annotation(
                    dict(font=dict(color=color_col[key][j], size=10),
                         x=pos_x_t,
                         y=pos_y,
                         xanchor="left",
                         yanchor="top",
                         showarrow=False,
                         text=range_col[key][j][0],
                         textangle=0,
                         xref='paper',
                         yref="paper"
                         )
                )

                fig.add_annotation(
                    dict(font=dict(color=color_col[key][j], size=10),
                         # x=x_loc,
                         x=pos_x_t+pos_x,
                         y=pos_y,
                         xanchor="right",
                         yanchor="top",
                         showarrow=False,
                         text=range_col[key][j][1],
                         textangle=0,
                         xref='paper',
                         yref="paper"
                         )
                )

            pos_y += 0.03
            pos_y = min(pos_y, 1.0)

        pos_x_t += pos_x
        pos_x_c += 0.5*pos_x

    return fig


def layout_draw_header_lines(fig, ratio_plots):
    """
    Fungsi untuk menggambar garis-garis pada area header saja
    """
    ratio_plots = np.array(ratio_plots)
    line_pos = []
    for i in ratio_plots:
        line_pos.append(
            i*(1/(ratio_plots/len(ratio_plots)).sum())/len(ratio_plots))

    shapes = []

    # Garis vertikal kiri (x=0) - hanya untuk area header (y dari 0.8 ke 1.0)
    shapes.append(
        dict(
            type='line', xref='paper', yref='paper',
            x0=0, x1=0, y0=1, y1=0.8,
            line=dict(color='black', width=1, dash='solid')
        )
    )

    # Garis vertikal pembatas antar kolom - hanya untuk area header
    x = 0
    for pos in line_pos:
        x += pos
        shapes.append(
            dict(
                type='line', xref='paper', yref='paper',
                x0=x, x1=x, y0=1, y1=0.8,
                line=dict(color='black', width=1, dash='solid')
            )
        )

    # Garis horizontal atas header (y=1.0)
    shapes.append(
        dict(
            type='line', xref='paper', yref='paper',
            x0=0, x1=1, y0=1, y1=1,
            line=dict(color='black', width=1, dash='solid')
        )
    )

    # Garis horizontal bawah header / pembatas dengan main (y=0.8)
    shapes.append(
        dict(
            type='line', xref='paper', yref='paper',
            x0=0, x1=1, y0=0.8, y1=0.8,
            line=dict(color='black', width=1, dash='solid')
        )
    )

    fig.update_layout(shapes=shapes)
    return fig


def layout_draw_main_lines(fig, ratio_plots, df_well, xgrid_intv):
    """
    Fungsi untuk menggambar garis-garis pada area main saja (tanpa header)
    """
    ratio_plots = np.array(ratio_plots)
    line_pos = []
    for i in ratio_plots:
        line_pos.append(
            i*(1/(ratio_plots/len(ratio_plots)).sum())/len(ratio_plots))

    shapes = []

    # Garis vertikal kiri (x=0) - hanya untuk area main (y dari 0 ke 0.8)
    shapes.append(
        dict(
            type='line', xref='paper', yref='paper',
            x0=0, x1=0, y0=0.9, y1=0,
            line=dict(color='black', width=1, dash='solid')
        )
    )

    # Garis vertikal pembatas antar kolom - hanya untuk area main
    x = 0
    for pos in line_pos:
        x += pos
        shapes.append(
            dict(
                type='line', xref='paper', yref='paper',
                x0=x, x1=x, y0=0.9, y1=0,
                line=dict(color='black', width=1, dash='solid')
            )
        )

    # Garis horizontal bawah main (y=0)
    shapes.append(
        dict(
            type='line', xref='paper', yref='paper',
            x0=0, x1=1, y0=0, y1=0,
            line=dict(color='black', width=1, dash='solid')
        )
    )

    # Plot grid horizontal (jika diperlukan)
    if xgrid_intv is not None and xgrid_intv != 0:
        # Asumsi 'depth' adalah nama kolom, sesuaikan dengan variabel yang tepat
        grid_lines = [dict(
            layer='below',
            type="line",
            x0=0, x1=1,
            xref="paper",
            # Normalisasi ke area main (0-0.9)
            y0=y * 0.9 / int(df_well['depth'].max()), y1=y * 0.9 / int(df_well['depth'].max()),
            line=dict(color="gainsboro", width=1)
        ) for y in range(0, int(df_well['depth'].max()), xgrid_intv)]

        shapes = shapes + grid_lines
        fig.update_layout(shapes=shapes, yaxis=dict(showgrid=False))
    else:
        fig.update_layout(shapes=shapes)

    return fig


def layout_axis_header(fig_main, axes, ratio_plots, plot_sequence):
    """
    Membuat figure header yang terpisah dari main plot
    Returns: fig_header - figure untuk header
    """
    import plotly.graph_objects as go

    # Buat figure baru untuk header
    fig_header = go.Figure()

    # Atur ukuran dan margin untuk header
    fig_header.update_layout(
        height=200,  # Tinggi header yang lebih kecil
        margin=dict(l=50, r=50, t=20, b=20),
        showlegend=False,
        plot_bgcolor='white',
        paper_bgcolor='white'
    )

    # Tambahkan annotation untuk depth label di header
    fig_header.add_annotation(
        dict(font=dict(color='black', size=12),
             x=-0.001,
             y=0.5,  # Posisi di tengah header
             xanchor="right",
             yanchor="middle",
             showarrow=False,
             text=depth+' (m)',
             textangle=-90,
             xref='paper',
             yref="paper"
             )
    )

    pos_x_c = 0
    ratio_plots = np.array(ratio_plots)
    line_pos = []
    for i in ratio_plots:
        line_pos.append(
            i*(1/(ratio_plots/len(ratio_plots)).sum())/len(ratio_plots))

    pos_x_t = 0
    for i, key in enumerate(axes.keys()):
        pos_x = line_pos[i]
        pos_y = 0.2  # Posisi untuk header (lebih rendah dari 0.85)
        pos_x_c += 0.5*pos_x

        # Ganti dengan key yang butuh semua axis (feature di datacol)
        if key in ['SWARRAY']:
            axis_range = axes[key][1:]  # Semua axis
        else:
            axis_range = axes[key][1:3]  # Hanya 2 axis pertama

        for j, axis in enumerate(axis_range):
            # UPDATE LAYOUT AXIS - SAMA SEPERTI KODE ASLI
            fig_header.update_layout(
                **{axis: dict(
                    tickfont=dict(color=color_col[key][j], size=9),
                    anchor="free",
                    showline=True,        # INI YANG BIKIN GARIS BERWARNA
                    position=pos_y,
                    showticklabels=False,
                    linewidth=1.5,
                    linecolor=color_col[key][j],  # WARNA GARIS
                )}
            )

            # Add Text Parameter
            fig_header.add_annotation(
                dict(font=dict(color=color_col[key][j], size=12),
                     x=pos_x_c,
                     y=pos_y,
                     xanchor="center",
                     yanchor="bottom",
                     showarrow=False,
                     text=data_col[key][j],
                     textangle=0,
                     xref='paper',
                     yref="paper"
                     )
            )

            # Add Text Unit
            fig_header.add_annotation(
                dict(font=dict(color=color_col[key][j], size=10),
                     x=pos_x_c,
                     y=pos_y,
                     xanchor="center",
                     yanchor="top",
                     showarrow=False,
                     text=unit_col[key][j],
                     textangle=0,
                     xref='paper',
                     yref="paper"
                     )
            )

            # Add Text Min Max Range
            if key not in ['CLASS', 'TEST', 'XPT', 'MARKER', 'ZONA', 'RESERVOIR_CLASS', 'RGBE', 'RPBE', 'IQUAL', 'RGBE_TEXT', 'RPBE_TEXT']:
                fig_header.add_annotation(
                    dict(font=dict(color=color_col[key][j], size=10),
                         x=pos_x_t,
                         y=pos_y,
                         xanchor="left",
                         yanchor="top",
                         showarrow=False,
                         text=range_col[key][j][0],
                         textangle=0,
                         xref='paper',
                         yref="paper"
                         )
                )

                fig_header.add_annotation(
                    dict(font=dict(color=color_col[key][j], size=10),
                         x=pos_x_t+pos_x,
                         y=pos_y,
                         xanchor="right",
                         yanchor="top",
                         showarrow=False,
                         text=range_col[key][j][1],
                         textangle=0,
                         xref='paper',
                         yref="paper"
                         )
                )

            # Increment posisi y untuk axis selanjutnya (seperti kode asli)
            pos_y += 0.35  # Lebih besar dari 0.04 karena ruang header lebih terbatas
            pos_y = min(pos_y, 1.0)

        pos_x_t += pos_x
        pos_x_c += 0.5*pos_x

    # Tambahkan garis pembatas vertikal di header
    shapes = []
    x = 0
    for pos in line_pos:
        x += pos
        shapes.append(
            dict(
                type='line', xref='paper', yref='paper',
                x0=x, x1=x, y0=0, y1=1,
                line=dict(color='black', width=1, dash='solid')
            )
        )

    # Garis border header
    shapes.extend([
        # Garis atas
        dict(type='line', xref='paper', yref='paper',
             x0=0, x1=1, y0=1, y1=1,
             line=dict(color='black', width=1, dash='solid')),
        # Garis bawah
        dict(type='line', xref='paper', yref='paper',
             x0=0, x1=1, y0=0, y1=0,
             line=dict(color='black', width=1, dash='solid')),
        # Garis kiri
        dict(type='line', xref='paper', yref='paper',
             x0=0, x1=0, y0=0, y1=1,
             line=dict(color='black', width=1, dash='solid')),
        # Garis kanan
        dict(type='line', xref='paper', yref='paper',
             x0=1, x1=1, y0=0, y1=1,
             line=dict(color='black', width=1, dash='solid'))
    ])

    fig_header.update_layout(shapes=shapes)

    # TIDAK hilangkan axis - biarkan axis tetap visible untuk menampilkan garis berwarna
    # Hanya hilangkan ticklabels dan grid
    fig_header.update_layout(
        xaxis=dict(showticklabels=False, showgrid=False, zeroline=False),
        yaxis=dict(showticklabels=False, showgrid=False, zeroline=False)
    )

    return fig_header
# ------------------------------ Other Func --------------------------------


def convert_depth_ft_to_m(df, column='DEPTH'):
    """
    Mengonversi nilai pada kolom 'DEPTH' dari feet ke meter.

    Args:
        df (pd.DataFrame): DataFrame yang memiliki kolom 'DEPTH'.
        column (str): Nama kolom yang akan dikonversi. Default 'DEPTH'.

    Returns:
        pd.DataFrame: DataFrame dengan kolom 'DEPTH' dalam satuan meter.
    """
    df[column] = df[column] * 0.3048  # 1 ft = 0.3048 m
    return df


def update_plot_sequence(plot_sequence, exclude_keys):
    filtered_items = [v for k, v in plot_sequence.items()
                      if v not in exclude_keys]
    return {i + 1: v for i, v in enumerate(filtered_items)}


def encode_with_nan(df, col):
    encoding_dict = {}
    df_encoded = df.copy()

    unique_vals = df[col].dropna().unique()
    col_map = {val: i+1 for i, val in enumerate(unique_vals)}
    flag_map = {i+1: val for i, val in enumerate(unique_vals)}

    encoding_dict[col] = flag_map

    col_map[None] = 0
    col_map[pd.NA] = 0

    df_encoded[col] = df[col].map(col_map).fillna(0).astype(int)

    col_map.pop(None, None)
    col_map.pop(pd.NA, None)

    encoding_dict[col].update({0: ''})

    return df_encoded, encoding_dict[col]


def get_random_color(pastel_factor=0.5):
    return [(x+pastel_factor)/(1.0+pastel_factor) for x in [random.uniform(0, 1.0) for i in [1, 2, 3]]]


def color_distance(c1, c2):
    return sum([abs(x[0]-x[1]) for x in zip(c1, c2)])


def generate_new_color(existing_colors, pastel_factor=0.5):
    max_distance = None
    best_color = None
    for i in range(0, 100):
        color = get_random_color(pastel_factor=pastel_factor)
        if not existing_colors:
            return color
        best_distance = min([color_distance(color, c)
                            for c in existing_colors.values()])
        if not max_distance or best_distance > max_distance:
            max_distance = best_distance
            best_color = color
    return best_color


def rgb_to_hex(rgb):
    """Convert RGB (0-1 range) to HEX."""
    return '#{:02x}{:02x}{:02x}'.format(
        int(rgb[0] * 255),
        int(rgb[1] * 255),
        int(rgb[2] * 255)
    )

# ------------------------------- Main Plot --------------------------------


def main_plot(df_well, title='Well Prediction', class_col=None, cutoff_dict=None, class_col_compare=None, exclude_marker=False,
              exclude_xpt=False, exclude_perm=False, exclude_crossover=False, xgrid_intv=0, df_xpt=None, df_well_marker=None, df_marker=None):
    # convert ft to meter:
    # df_well = convert_depth_ft_to_m(df_well, column='DEPTH')
    sequence = ['MARKER', 'GR', 'RT_RO', 'NPHI_RHOB', "XPT", 'VCL', 'PHIE_PHIT', 'SW', 'PERM',
                'X_RT_RO', 'RWAPP_RW', 'X_RWA_RW', 'RT_F', 'X_RT_F', 'RT_RHOB', 'X_RT_RHOB', 'TEST']

    if class_col:
        sequence.append('CLASS')
        data_col.update({'CLASS': [class_col]})
    if class_col_compare:
        sequence.append('CTC')
        plot_sequence.update({17: 'CTC'})
    if exclude_marker:
        sequence.remove('MARKER')
    if exclude_xpt:
        sequence.remove('XPT')
    if exclude_perm:
        sequence.remove('PERM')
    if exclude_crossover:
        print(exclude_crossover)
        x_over_col = {'X_RT_RO', 'X_RWA_RW', 'X_RT_F', 'X_RT_RHOB'}
        sequence = [col for col in sequence if col not in x_over_col]
        print(sequence)

    plot_sequence = {i+1: v for i, v in enumerate(sequence)}
    print(plot_sequence)


# Create subplots with no gap between them
    if cutoff_dict:
        thres.update({
            'RTRO': cutoff_dict['rt_ro'] or 1.2,
            'RWARW': cutoff_dict['rwa_rw'] or 1.4,
            'RTF': cutoff_dict['rt_f'] or 0.7,
            'RTRHOB': cutoff_dict['rt_rhob'] or 0.02
        })

    ratio_plots_seq = []
    for key in plot_sequence.values():
        ratio_plots_seq.append(ratio_plots[key])

    subplot_col = len(plot_sequence.keys())

    fig = make_subplots(
        rows=1, cols=subplot_col,
        shared_yaxes=True,
        column_widths=ratio_plots_seq,
        horizontal_spacing=0.0  # No gap between columns
    )

    counter = 0
    axes = {}
    for i in plot_sequence.values():
        axes[i] = []

    for n_seq, key in plot_sequence.items():
        if key == 'GR':
            fig, axes = plot_line(df_well, fig, axes, key, n_seq)
        elif key == 'NPHI_RHOB':
            fig, axes, counter = plot_xover_log_normal(df_well, fig, axes, key, n_seq, counter, n_plots=subplot_col,
                                                       y_color='rgba(0,0,0,0)', n_color='yellow', type=2, exclude_crossover=exclude_crossover)
        elif key == 'SW':
            fig, axes = plot_line(df_well, fig, axes, key, n_seq)
        elif key == 'PHIE_PHIT':
            fig, axes, counter = plot_n_fill_x_to_zero(
                df_well, fig, axes, key, n_seq, counter=counter, n_plots=subplot_col)
        elif key == 'PERM':
            fig, axes = plot_line(df_well, fig, axes, key, n_seq, type='log')
        elif key == 'VCL':
            fig, axes = plot_fill_x_to_zero(
                df_well, fig, axes, key, n_seq, index=0)
        elif key in ['RT_RO', 'RWAPP_RW', 'RT_F']:
            fig, axes, counter = plot_xover(
                df_well, fig, axes, key, n_seq, counter, n_plots=subplot_col, y_color='limegreen', n_color='lightgray')
        elif key in ['X_RT_RO', 'X_RWA_RW', 'X_RT_F', 'X_RT_RHOB']:
            fig, axes, counter = plot_xover_thres(
                df_well, fig, axes, key, n_seq, counter=counter)
        elif key == 'RT_RHOB':
            fig, axes, counter = plot_xover_log_normal(df_well, fig, axes, key, n_seq, counter, n_plots=subplot_col,
                                                       y_color='limegreen', n_color='lightgray', type=1, exclude_crossover=exclude_crossover)
        elif key == 'TEST':
            fig, axes = plot_flag(df_well, fig, axes, key, n_seq)
        elif key == 'CLASS':
            fig, axes = plot_flag(df_well, fig, axes, key, n_seq)
        elif key == 'CTC':
            fig, axes = plot_flag(df_well, fig, axes, key, n_seq)
        elif key == 'MARKER':
            fig, axes = plot_flag(df_well_marker, fig, axes, key, n_seq)
            fig, axes = plot_texts_marker(
                df_marker, df_well_marker['DEPTH'].max(), fig, axes, key, n_seq)
        elif key == 'XPT':
            fig, axes = plot_xpt(df_well, fig, axes, key, n_seq)
            fig, axes = plot_texts_xpt(df_xpt, fig, axes, key, n_seq)

    fig = layout_range_all_axis(fig, axes, plot_sequence)

    fig.update_layout(
        margin=dict(l=20, r=20, t=40, b=20), height=600,
        paper_bgcolor='white',
        plot_bgcolor='white',
        showlegend=False,
        hovermode='y unified', hoverdistance=-1,
        title_text=title,
        title_x=0.5,
        modebar_remove=['lasso', 'autoscale', 'zoom',
                        'zoomin', 'zoomout', 'pan', 'select']
    )

    fig.update_yaxes(showspikes=True,  # tickangle=90,
                     range=[df_well[depth].max(), df_well[depth].min()])
    fig.update_traces(yaxis='y')

    fig = layout_draw_lines(fig, ratio_plots_seq, df_well, xgrid_intv=0)

    fig = layout_axis(fig, axes, ratio_plots_seq, plot_sequence)

    return fig

# @title


def extract_markers_with_mean_depth(df):
    """
    Membuat dataframe baru yang berisi nilai unik dari marker (sebagai 'surface')
    dan rata-rata depth untuk setiap marker.

    Parameters:
    -----------
    df : pandas.DataFrame
        DataFrame yang berisi kolom 'MARKER' dan 'DEPTH'

    Returns:
    --------
    pandas.DataFrame
        DataFrame baru dengan kolom 'surface' (nama marker) dan 'mean_depth'
    """
    # Pastikan df memiliki kolom 'MARKER' dan 'DEPTH'
    required_cols = ['MARKER', 'DEPTH']
    for col in required_cols:
        if col not in df.columns:
            raise ValueError(f"DataFrame tidak memiliki kolom '{col}'")

    # Mengelompokkan berdasarkan MARKER dan menghitung rata-rata DEPTH
    markers_mean_depth = df.groupby('MARKER')['DEPTH'].mean().reset_index()

    # Mengganti nama kolom
    markers_mean_depth.columns = ['Surface', 'Mean Depth']

    return markers_mean_depth

# @title


def extract_markers_customize(df, key):
    required_cols = [key, 'DEPTH']
    for col in required_cols:
        if col not in df.columns:
            raise ValueError(f"DataFrame tidak memiliki kolom '{col}'")

    # Mengelompokkan berdasarkan MARKER dan menghitung rata-rata DEPTH
    markers_mean_depth = df.groupby(key)['DEPTH'].mean().reset_index()

    # Mengganti nama kolom
    markers_mean_depth.columns = ['Surface', 'Mean Depth']

    # PERBAIKAN: Convert kolom Surface ke string untuk menghindari IndexError saat slicing
    markers_mean_depth['Surface'] = markers_mean_depth['Surface'].astype(str)

    return markers_mean_depth

# @title


def normalize_xover(df_well, log_1, log_2):

    # Salin DataFrame untuk menghindari modifikasi pada original
    df = df_well.copy()
    log_merge = log_1 + '_' + log_2
    log_1_norm = log_1 + '_NORM'
    log_2_norm = log_2 + '_NORM_' + log_1

    # Range untuk visualisasi
    log_1_range = range_col[log_merge][0]
    log_2_range = range_col[log_merge][1]

    # 1. Normalisasi NPHI agar sesuai dengan rentang visualisasi
    # Nilai NPHI biasanya dalam desimal (misalnya 0.3 untuk 30% porositas)
    # NPHI_NORM tetap dalam skala aslinya
    df[log_1_norm] = df[log_1]

    # 2. Konversi RHOB ke skala NPHI untuk visualisasi crossover
    # Ini membuat RHOB sesuai dengan skala NPHI agar crossover terlihat
    min_log_2 = log_2_range[0]  # 1.71
    max_log_2 = log_2_range[1]  # 2.71
    min_log_1 = log_1_range[0]  # 0.6
    max_log_1 = log_1_range[1]  # 0

    # Normalisasi RHOB dengan rumus interpolasi linier untuk pemetaan rentang
    df[log_2_norm] = min_log_1 + \
        (df[log_2] - min_log_2) * (max_log_1 -
                                   min_log_1) / (max_log_2 - min_log_2)

    return df


"""# Module 1"""

"""## Log ABB-036"""

# @title


def plot_log_default(df, df_marker, df_well_marker):
    sequence = ['MARKER', 'GR', 'RT_RHOB', 'NPHI_RHOB']
    plot_sequence = {i+1: v for i, v in enumerate(sequence)}
    print(plot_sequence)

    ratio_plots_seq = []
    for key in plot_sequence.values():
        ratio_plots_seq.append(ratio_plots[key])

    subplot_col = len(plot_sequence.keys())

    fig = make_subplots(
        rows=1, cols=subplot_col,
        shared_yaxes=True,
        column_widths=ratio_plots_seq,
        horizontal_spacing=0.0
    )

    counter = 0
    axes = {}
    for i in plot_sequence.values():
        axes[i] = []

    for n_seq, col in plot_sequence.items():
        if col == 'GR':
            fig, axes = plot_line(
                df, fig, axes, base_key='GR', n_seq=n_seq, col=col, label=col)
        elif col == 'RT':
            fig, axes = plot_line(
                df, fig, axes, base_key='RT', n_seq=n_seq, col=col, label=col)
        elif col == 'NPHI_RHOB':
            fig, axes, counter = plot_xover_log_normal(df, fig, axes, col, n_seq, counter, n_plots=subplot_col,
                                                       y_color='rgba(0,0,0,0)', n_color='yellow', type=2, exclude_crossover=False)
        elif col == 'RT_RHOB':
            fig, axes, counter = plot_xover_log_normal(df, fig, axes, col, n_seq, counter, n_plots=subplot_col,
                                                       y_color='limegreen', n_color='lightgray', type=1, exclude_crossover=False)
        elif col in ['X_RT_RO', 'X_RWA_RW', 'X_RT_F', 'X_RT_RHOB']:
            fig, axes, counter = plot_xover_thres(
                df, fig, axes, col, n_seq, counter=counter)
        elif col == 'MARKER':
            fig, axes = plot_flag(df_well_marker, fig, axes, col, n_seq)
            fig, axes = plot_texts_marker(
                df_marker, df_well_marker['DEPTH'].max(), fig, axes, col, n_seq)

    fig = layout_range_all_axis(fig, axes, plot_sequence)

    fig.update_layout(
        margin=dict(l=20, r=20, t=40, b=20), height=1500,
        paper_bgcolor='white',
        plot_bgcolor='white',
        showlegend=False,
        hovermode='y unified', hoverdistance=-1,
        title_text="Well Log Selected",
        title_x=0.5,
        modebar_remove=['lasso', 'autoscale', 'zoom',
                        'zoomin', 'zoomout', 'pan', 'select']
    )

    fig.update_yaxes(showspikes=True,  # tickangle=90,
                     range=[df[depth].max(), df[depth].min()])
    fig.update_traces(yaxis='y')

    fig = layout_draw_lines(fig, ratio_plots_seq, df, xgrid_intv=0)

    fig = layout_axis(fig, axes, ratio_plots_seq, plot_sequence)
    return fig


def plot_normalization(df):
    df_marker = extract_markers_with_mean_depth(df)
    df_well_marker = df.copy()
    sequence = ['MARKER', 'GR', 'GR_DUAL_2', 'GR_DUAL', 'GR_RAW_NORM']
    plot_sequence = {i+1: v for i, v in enumerate(sequence)}
    print(plot_sequence)

    ratio_plots_seq = []
    ratio_plots_seq.append(ratio_plots['MARKER'])
    sequence_keys = list(plot_sequence.values())
    for key in sequence_keys[1:]:
        ratio_plots_seq.append(ratio_plots[key])

    subplot_col = len(plot_sequence.keys())

    fig = make_subplots(
        rows=1, cols=subplot_col,
        shared_yaxes=True,
        column_widths=ratio_plots_seq,
        horizontal_spacing=0.0
    )

    counter = 0
    axes = {}
    for i in plot_sequence.values():
        axes[i] = []

    # Plot Marker
    fig, axes = plot_flag(df_well_marker, fig, axes,
                          "MARKER", 1)  # n_seq=1 for marker
    fig, axes = plot_texts_marker(
        df_marker, df_well_marker['DEPTH'].max(), fig, axes, "MARKER", 1)

    # Plot GR - start from n_seq=2 which is 'GR' in your sequence
    for n_seq, col in plot_sequence.items():
        if n_seq > 1:
            if col == 'GR':  # Skip n_seq=1 which is 'MARKER'
                fig, axes = plot_line(
                    df, fig, axes, base_key=col, n_seq=n_seq, col=col, label=col)
            elif col == 'GR_DUAL_2':
                fig, axes, counter = plot_dual_gr(
                    df, fig, axes, col, n_seq, counter, subplot_col)
            elif col == 'GR_DUAL':
                fig, axes, counter = plot_dual_gr(
                    df, fig, axes, col, n_seq, counter, subplot_col)
            elif col == 'GR_RAW_NORM':
                fig, axes = plot_line(
                    df, fig, axes, base_key=col, n_seq=n_seq, col=col, label=col)

    fig = layout_range_all_axis(fig, axes, plot_sequence)

    fig.update_layout(
        margin=dict(l=20, r=20, t=40, b=20), height=1300,
        paper_bgcolor='white',
        plot_bgcolor='white',
        showlegend=False,
        hovermode='y unified', hoverdistance=-1,
        title_text="Normalization",
        title_x=0.5,
        modebar_remove=['lasso', 'autoscale', 'zoom',
                        'zoomin', 'zoomout', 'pan', 'select']
    )

    fig.update_yaxes(showspikes=True,
                     range=[df[depth].max(), df[depth].min()])
    fig.update_traces(yaxis='y')

    fig = layout_draw_lines(fig, ratio_plots_seq, df, xgrid_intv=0)

    fig = layout_axis(fig, axes, ratio_plots_seq, plot_sequence)

    print(axes)

    return fig


def plot_phie_den(df, df_marker, df_well_marker):
    """
    Membuat plot multi-panel untuk visualisasi hasil kalkulasi Porositas.
    """
    df = normalize_xover(df, 'NPHI', 'RHOB')
    df = normalize_xover(df, 'RT', 'RHOB')
    df = normalize_xover(df, 'PHIE', 'PHIT')

    sequence = ['MARKER', 'GR', 'RT_RHOB', 'NPHI_RHOB', 'VSH', 'PHIE_PHIT']
    plot_sequence = {i+1: v for i, v in enumerate(sequence)}

    ratio_plots_seq = [ratio_plots.get(key, 1)
                       for key in plot_sequence.values()]
    subplot_col = len(plot_sequence)

    fig = make_subplots(
        rows=1, cols=subplot_col,
        shared_yaxes=True,
        column_widths=ratio_plots_seq,
        horizontal_spacing=0.01
    )

    counter = 0
    axes = {key: [] for key in plot_sequence.values()}

    # Loop untuk memanggil plotter yang sesuai
    for n_seq, col in plot_sequence.items():
        if col == 'GR':
            fig, axes = plot_line(
                df, fig, axes, base_key='GR', n_seq=n_seq, col=col, label=col)
        elif col == 'RHOB':
            fig, axes = plot_line(
                df, fig, axes, base_key='RHOB', n_seq=n_seq, col=col, label=col)
        elif col == 'NPHI_RHOB':
            fig, axes, counter = plot_xover_log_normal(
                df, fig, axes, col, n_seq, counter, n_plots=subplot_col, y_color='rgba(0,0,0,0)', n_color='yellow', type=2, exclude_crossover=False)
        elif col == 'RT_RHOB':
            fig, axes, counter = plot_xover_log_normal(df, fig, axes, col, n_seq, counter, n_plots=subplot_col,
                                                       y_color='limegreen', n_color='lightgray', type=1, exclude_crossover=False)
        elif col == 'PHIE_PHIT':
            fig, axes, counter = plot_xover_log_normal(df, fig, axes, col, n_seq, counter, n_plots=subplot_col,
                                                       y_color='limegreen', n_color='lightgray', type=1, exclude_crossover=False)
        elif col == 'VSH':
            fig, axes == plot_line(
                df, fig, axes, base_key='VSH', n_seq=n_seq, col=col, label=col)
        elif col == 'MARKER':
            fig, axes = plot_flag(df_well_marker, fig, axes, col, n_seq)
            fig, axes = plot_texts_marker(
                df_marker, df_well_marker['DEPTH'].max(), fig, axes, col, n_seq)

    # Panggil fungsi-fungsi layout akhir
    fig = layout_range_all_axis(fig, axes, plot_sequence)
    fig = layout_draw_lines(fig, ratio_plots_seq, df,
                            xgrid_intv=50)  # Memberi grid interval 50
    fig = layout_axis(fig, axes, ratio_plots_seq, plot_sequence)

    # Atur layout global
    fig.update_layout(
        margin=dict(l=40, r=20, t=80, b=40),
        height=1600,
        paper_bgcolor='white',
        plot_bgcolor='white',
        showlegend=False,
        hovermode='y unified',
        title_text="Porosity from Density (RHOB)",
        title_x=0.5,
    )
    fig.update_yaxes(autorange='reversed', range=[
                     df[depth].max(), df[depth].min()])
    fig.update_traces(yaxis='y')

    return fig


def plot_gsa_main(df_well):
    """
    Fungsi utama untuk membuat plot komprehensif Gas Show Anomaly.
    """
    # Lakukan pra-pemrosesan data yang diperlukan untuk plot ini
    df_well = normalize_xover(df_well, 'NPHI', 'RHOB')
    df_well = normalize_xover(df_well, 'RT', 'RHOB')
    df_well = normalize_xover(df_well, 'RT', 'RGSA')
    df_well = normalize_xover(df_well, 'NPHI', 'NGSA')
    df_well = normalize_xover(df_well, 'RHOB', 'DGSA')

    zona_mapping = {
        'Zona Prospek Kuat': 3,
        'Zona Menarik': 2,
        'Zona Lemah': 1,
        'Non Prospek': 0
    }

    df_well['ZONA'] = df_well['ZONA'].map(zona_mapping)
    df_marker = extract_markers_with_mean_depth(df_well)
    df_well_marker = df_well.copy()

    # Definisikan urutan track untuk plot GSA
    sequence = ['MARKER', 'GR', 'RT_RHOB', 'NPHI_RHOB',
                'RT_RGSA', 'NPHI_NGSA', 'RHOB_DGSA', 'ZONA']
    plot_sequence = {i+1: v for i, v in enumerate(sequence)}

    ratio_plots_seq = [ratio_plots.get(key, 1)
                       for key in plot_sequence.values()]
    subplot_col = len(plot_sequence)

    fig = make_subplots(
        rows=1, cols=subplot_col,
        shared_yaxes=True,
        column_widths=ratio_plots_seq,
        horizontal_spacing=0.01
    )

    counter = 0
    axes = {key: [] for key in plot_sequence.values()}

    # Loop untuk memanggil plotter yang sesuai untuk setiap track
    for n_seq, key in plot_sequence.items():
        if key == 'MARKER':
            fig, axes = plot_flag(df_well_marker, fig, axes, key, n_seq)
            fig, axes = plot_texts_marker(
                df_marker, df_well_marker['DEPTH'].max(), fig, axes, key, n_seq)
        elif key == 'GR':
            fig, axes = plot_line(df_well, fig, axes, key, n_seq)
        elif key in ['NPHI_RHOB', 'RT_RHOB']:
            fig, axes, counter = plot_xover_log_normal(
                df_well, fig, axes, key, n_seq, counter, subplot_col)
        elif key in ['RT_RGSA', 'NPHI_NGSA', 'RHOB_DGSA']:
            fig, axes, counter = plot_gsa_crossover(
                df_well, fig, axes, key, n_seq, counter, subplot_col)
        elif key == 'ZONA':
            fig, axes = plot_flag(df_well, fig, axes, key, n_seq)

    # Finalisasi Layout
    fig = layout_range_all_axis(fig, axes, plot_sequence)
    fig = layout_draw_lines(fig, ratio_plots_seq, df_well, xgrid_intv=50)
    fig = layout_axis(fig, axes, ratio_plots_seq, plot_sequence)

    fig.update_layout(
        title_text="Gas Show Anomaly (GSA) Analysis",
        yaxis=dict(range=[
                   df_well[depth].max(), df_well[depth].min()]),
        hovermode='y unified',
        template='plotly_white',
        showlegend=False,
        height=1600,
    )

    return fig

# @title


def plot_smoothing(df, df_marker, df_well_marker):
    sequence = ['MARKER', 'GR', 'GR_MovingAvg_5', 'GR_MovingAvg_10']
    plot_sequence = {i+1: v for i, v in enumerate(sequence)}
    print(plot_sequence)

    ratio_plots_seq = []
    for key in plot_sequence.values():
        ratio_plots_seq.append(ratio_plots[key])

    subplot_col = len(plot_sequence.keys())

    fig = make_subplots(
        rows=1, cols=subplot_col,
        shared_yaxes=True,
        column_widths=ratio_plots_seq,
        horizontal_spacing=0.0
    )

    counter = 0
    axes = {}
    for i in plot_sequence.values():
        axes[i] = []

    for n_seq, col in plot_sequence.items():
        if col == 'GR':
            fig, axes = plot_line(
                df, fig, axes, base_key='GR', n_seq=n_seq, col=col, label=col)
        elif col == 'GR_MovingAvg_5':
            fig, axes = plot_line(
                df, fig, axes, base_key='GR', n_seq=n_seq, col=col, label=col)
        elif col == 'GR_MovingAvg_10':
            fig, axes = plot_line(
                df, fig, axes, base_key='GR', n_seq=n_seq, col=col, label=col)
        elif col == 'MARKER':
            fig, axes = plot_flag(df_well_marker, fig, axes, col, n_seq)
            fig, axes = plot_texts_marker(
                df_marker, df_well_marker['DEPTH'].max(), fig, axes, col, n_seq)

    fig = layout_range_all_axis(fig, axes, plot_sequence)

    fig.update_layout(
        margin=dict(l=20, r=20, t=40, b=20), height=1300,
        paper_bgcolor='white',
        plot_bgcolor='white',
        showlegend=False,
        hovermode='y unified', hoverdistance=-1,
        title_text="Well Log ABB-036",
        title_x=0.5,
        modebar_remove=['lasso', 'autoscale', 'zoom',
                        'zoomin', 'zoomout', 'pan', 'select']
    )

    fig.update_yaxes(showspikes=True,  # tickangle=90,
                     range=[df[depth].max(), df[depth].min()])
    fig.update_traces(yaxis='y')

    fig = layout_draw_lines(fig, ratio_plots_seq, df, xgrid_intv=0)

    fig = layout_axis(fig, axes, ratio_plots_seq, plot_sequence)
    return fig


def plot_vsh_linear(df, df_marker, df_well_marker):
    """
    Membuat plot multi-panel untuk visualisasi hasil kalkulasi VSH.
    """

    df = normalize_xover(df, 'NPHI', 'RHOB')
    df = normalize_xover(df, 'RT', 'RHOB')

    sequence = ['MARKER', 'GR', 'RT_RHOB', 'NPHI_RHOB', 'VSH_LINEAR']
    plot_sequence = {i + 1: v for i, v in enumerate(sequence)}

    ratio_plots_seq = [ratio_plots.get(key, 1)
                       for key in plot_sequence.values()]
    subplot_col = len(plot_sequence)

    fig = make_subplots(
        rows=1, cols=subplot_col,
        shared_yaxes=True,
        column_widths=ratio_plots_seq,
        horizontal_spacing=0.01
    )

    counter = 0
    axes = {key: [] for key in plot_sequence.values()}

    for n_seq, key in plot_sequence.items():
        if key == 'MARKER':
            fig, axes = plot_flag(df_well_marker, fig, axes, key, n_seq)
            fig, axes = plot_texts_marker(
                df_marker, df_well_marker[depth].max(), fig, axes, key, n_seq)
        elif key == 'GR':
            fig, axes = plot_line(
                df, fig, axes, base_key='GR', n_seq=n_seq, col='GR', label='GR')
        elif key in ['NPHI_RHOB', 'RT_RHOB']:
            fig, axes, counter = plot_xover_log_normal(
                df, fig, axes, key, n_seq, counter, subplot_col)
        elif key == 'VSH_LINEAR':
            fig, axes = plot_line(df, fig, axes, base_key='VSH_LINEAR',
                                  n_seq=n_seq, col='VSH_LINEAR', label='VSH_LINEAR')

    # Panggil fungsi-fungsi layout akhir
    fig = layout_range_all_axis(fig, axes, plot_sequence)
    fig = layout_draw_lines(fig, ratio_plots_seq, df, xgrid_intv=50)
    fig = layout_axis(fig, axes, ratio_plots_seq, plot_sequence)

    # Atur layout global
    fig.update_layout(
        margin=dict(l=40, r=20, t=80, b=40),
        height=1600,
        paper_bgcolor='white',
        plot_bgcolor='white',
        showlegend=False,
        hovermode='y unified',
        title_text="VSH from Gamma Ray (Linear)",
        title_x=0.5,
    )
    fig.update_yaxes(autorange='reversed', range=[
                     df[depth].max(), df[depth].min()])
    fig.update_traces(yaxis='y')

    return fig


def plot_sw_indo(df, df_marker, df_well_marker):
    """
    Membuat plot multi-panel untuk visualisasi hasil kalkulasi Saturasi Air (Indonesia).
    """
    df = normalize_xover(df, 'RT', 'RHOB')

    sequence = ['MARKER', 'GR', 'VSH', 'RT_RHOB',
                'PHIE_DEN', 'SW']
    plot_sequence = {i + 1: v for i, v in enumerate(sequence)}

    # Pastikan semua key di sequence ada di kamus ratio_plots
    ratio_plots_seq = [ratio_plots.get(key, 1)
                       for key in plot_sequence.values()]
    subplot_col = len(plot_sequence)

    fig = make_subplots(
        rows=1, cols=subplot_col,
        shared_yaxes=True,
        column_widths=ratio_plots_seq,
        horizontal_spacing=0.01
    )

    counter = 0
    axes = {key: [] for key in plot_sequence.values()}

    # Loop untuk memanggil plotter yang sesuai
    for n_seq, key in plot_sequence.items():
        if key == 'MARKER':
            fig, axes = plot_flag(df_well_marker, fig, axes, key, n_seq)
            fig, axes = plot_texts_marker(
                df_marker, df_well_marker[depth].max(), fig, axes, key, n_seq)
        elif key in ['GR', 'VSH']:
            fig, axes = plot_line(
                df, fig, axes, base_key=key, n_seq=n_seq, col=key, label=key)
        elif key == 'RT_RHOB':
            fig, axes, counter = plot_xover_log_normal(
                df, fig, axes, key, n_seq, counter, subplot_col)
        elif key == 'PHIE_DEN':
            fig, axes, counter = plot_two_features_simple(
                df, fig, axes, 'PHIE_DEN', n_seq, counter, n_plots=subplot_col)
        elif key == 'SW':
            fig, axes = plot_line(
                df, fig, axes, base_key=key, n_seq=n_seq, col=key, label=key)

    # Finalisasi Layout
    fig = layout_range_all_axis(fig, axes, plot_sequence)
    fig = layout_draw_lines(fig, ratio_plots_seq, df, xgrid_intv=50)
    fig = layout_axis(fig, axes, ratio_plots_seq, plot_sequence)

    fig.update_layout(
        title_text="Water Saturation (Indonesia Method) Analysis",
        yaxis=dict(autorange='reversed', range=[
                   df[depth].max(), df[depth].min()]), showlegend=False,
        hovermode='y unified', template='plotly_white', height=1600,
    )
    return fig


def plot_rwa_indo(df, df_marker, df_well_marker):
    """
    Membuat plot multi-panel untuk visualisasi hasil kalkulasi RWA.
    """
    df = normalize_xover(df, 'RT', 'RHOB')

    sequence = ['MARKER', 'GR', 'VSH', 'RT_RHOB', 'PHIE', 'RWA']
    plot_sequence = {i + 1: v for i, v in enumerate(sequence)}

    ratio_plots_seq = [ratio_plots.get(key, 1)
                       for key in plot_sequence.values()]
    subplot_col = len(plot_sequence)

    fig = make_subplots(
        rows=1, cols=subplot_col,
        shared_yaxes=True,
        column_widths=ratio_plots_seq,
        horizontal_spacing=0.01
    )

    counter = 0
    axes = {key: [] for key in plot_sequence.values()}

    for n_seq, key in plot_sequence.items():
        if key == 'MARKER':
            fig, axes = plot_flag(df_well_marker, fig, axes, key, n_seq)
            fig, axes = plot_texts_marker(
                df_marker, df_well_marker[depth].max(), fig, axes, key, n_seq)
        elif key in ['GR', 'VSH', 'PHIE']:
            fig, axes = plot_line(
                df, fig, axes, base_key=key, n_seq=n_seq, col=key, label=key)
        elif key == 'RT_RHOB':
            fig, axes, counter = plot_xover_log_normal(
                df, fig, axes, key, n_seq, counter, subplot_col)
        elif key == 'RWA':
            fig, axes, counter = plot_three_features_simple(
                df, fig, axes, key, n_seq, counter, subplot_col, log_scale=True)

    # Finalisasi Layout
    fig = layout_range_all_axis(fig, axes, plot_sequence)
    fig = layout_draw_lines(fig, ratio_plots_seq, df, xgrid_intv=50)
    fig = layout_axis(fig, axes, ratio_plots_seq, plot_sequence)

    fig.update_layout(
        title_text="Apparent Water Resistivity (RWA) Analysis",
        yaxis=dict(autorange='reversed', range=[
                   df[depth].max(), df[depth].min()]),
        hovermode='y unified', template='plotly_white', height=1600,
        showlegend=False
    )
    return fig
